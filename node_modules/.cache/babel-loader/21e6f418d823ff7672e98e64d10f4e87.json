{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/createSuper\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nvar _excluded = [\"children\", \"slideWidth\", \"slideIndex\", \"isDraggable\", \"onDragStart\", \"onDragEnd\", \"onChange\", \"onEnd\", \"align\", \"bullets\", \"platform\", \"hasMouse\", \"showArrows\", \"window\", \"document\", \"getRef\", \"getRootRef\"],\n    _excluded2 = [\"initialSlideIndex\", \"children\", \"timeout\", \"onChange\"];\nimport { createScopedElement } from \"../../lib/jsxRuntime\";\nimport * as React from \"react\";\nimport { getClassName } from \"../../helpers/getClassName\";\nimport { Touch } from \"../Touch/Touch\";\nimport { classNames } from \"../../lib/classNames\";\nimport { withPlatform } from \"../../hoc/withPlatform\";\nimport { withDOM } from \"../../lib/dom\";\nimport { setRef } from \"../../lib/utils\";\nimport { withAdaptivity } from \"../../hoc/withAdaptivity\";\nimport HorizontalScrollArrow from \"../HorizontalScroll/HorizontalScrollArrow\";\nimport { clamp } from \"../../helpers/math\";\nimport { useTimeout } from \"../../hooks/useTimeout\";\n\nvar BaseGallery = /*#__PURE__*/function (_React$Component) {\n  _inherits(BaseGallery, _React$Component);\n\n  var _super = _createSuper(BaseGallery);\n\n  function BaseGallery(props) {\n    var _this;\n\n    _classCallCheck(this, BaseGallery);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"container\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"slidesStore\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"viewport\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"onStart\", function () {\n      _this.setState({\n        animation: false\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onMoveX\", function (e) {\n      if (_this.props.isDraggable && !_this.isFullyVisible) {\n        e.originalEvent.preventDefault();\n\n        if (e.isSlideX) {\n          _this.props.onDragStart && _this.props.onDragStart(e);\n\n          if (_this.state.deltaX !== e.shiftX || _this.state.dragging !== e.isSlideX) {\n            _this.setState({\n              deltaX: e.shiftX,\n              dragging: e.isSlideX\n            });\n          }\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onEnd\", function (e) {\n      var _this$props$slideInde;\n\n      var targetIndex = e.isSlide ? _this.getTarget(e) : (_this$props$slideInde = _this.props.slideIndex) !== null && _this$props$slideInde !== void 0 ? _this$props$slideInde : 0;\n      _this.props.onDragEnd && _this.props.onDragEnd(e);\n\n      _this.setState({\n        deltaX: 0,\n        animation: true\n      }, function () {\n        var _this$props$onChange, _this$props;\n\n        return (_this$props$onChange = (_this$props = _this.props).onChange) === null || _this$props$onChange === void 0 ? void 0 : _this$props$onChange.call(_this$props, targetIndex);\n      });\n\n      if (_this.props.onEnd) {\n        _this.props.onEnd({\n          targetIndex: targetIndex\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onResize\", function () {\n      return _this.initializeSlides({\n        animation: false\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"slideLeft\", function () {\n      var _this$props2 = _this.props,\n          _this$props2$slideInd = _this$props2.slideIndex,\n          slideIndex = _this$props2$slideInd === void 0 ? 0 : _this$props2$slideInd,\n          onChange = _this$props2.onChange;\n\n      if (_this.canSlideLeft) {\n        _this.setState({\n          deltaX: 0,\n          animation: true\n        }, function () {\n          return onChange === null || onChange === void 0 ? void 0 : onChange(slideIndex - 1);\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"slideRight\", function () {\n      var _this$props3 = _this.props,\n          _this$props3$slideInd = _this$props3.slideIndex,\n          slideIndex = _this$props3$slideInd === void 0 ? 0 : _this$props3$slideInd,\n          onChange = _this$props3.onChange;\n\n      if (_this.canSlideRight) {\n        _this.setState({\n          deltaX: 0,\n          animation: true\n        }, function () {\n          return onChange === null || onChange === void 0 ? void 0 : onChange(slideIndex + 1);\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getSlideRef\", function (id) {\n      return function (slide) {\n        _this.slidesStore[\"slide-\".concat(id)] = slide;\n      };\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getViewportRef\", function (viewport) {\n      _this.viewport = viewport;\n\n      if (_this.props.getRef) {\n        setRef(viewport, _this.props.getRef);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getRootRef\", function (container) {\n      _this.container = container;\n\n      if (_this.props.getRootRef) {\n        setRef(container, _this.props.getRootRef);\n      }\n    });\n\n    _this.state = {\n      containerWidth: 0,\n      deltaX: 0,\n      shiftX: 0,\n      slides: [],\n      animation: true,\n      duration: 0.24\n    };\n    _this.slidesStore = {};\n    return _this;\n  }\n\n  _createClass(BaseGallery, [{\n    key: \"isCenterWithCustomWidth\",\n    get: function get() {\n      return this.props.slideWidth === \"custom\" && this.props.align === \"center\";\n    }\n  }, {\n    key: \"initializeSlides\",\n    value: function initializeSlides() {\n      var _React$Children$map,\n          _this2 = this,\n          _this$container$offse,\n          _this$container;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var slides = (_React$Children$map = React.Children.map(this.props.children, function (_item, i) {\n        var _elem$offsetLeft, _elem$offsetWidth;\n\n        var elem = _this2.slidesStore[\"slide-\".concat(i)];\n\n        return {\n          coordX: (_elem$offsetLeft = elem === null || elem === void 0 ? void 0 : elem.offsetLeft) !== null && _elem$offsetLeft !== void 0 ? _elem$offsetLeft : 0,\n          width: (_elem$offsetWidth = elem === null || elem === void 0 ? void 0 : elem.offsetWidth) !== null && _elem$offsetWidth !== void 0 ? _elem$offsetWidth : 0\n        };\n      })) !== null && _React$Children$map !== void 0 ? _React$Children$map : [];\n      var containerWidth = (_this$container$offse = (_this$container = this.container) === null || _this$container === void 0 ? void 0 : _this$container.offsetWidth) !== null && _this$container$offse !== void 0 ? _this$container$offse : 0;\n      var layerWidth = slides.reduce(function (val, slide) {\n        return slide.width + val;\n      }, 0);\n      var min = this.calcMin({\n        containerWidth: containerWidth,\n        layerWidth: layerWidth,\n        slides: slides\n      });\n      var max = this.calcMax({\n        slides: slides\n      });\n      this.setState({\n        min: min,\n        max: max,\n        layerWidth: layerWidth,\n        containerWidth: containerWidth,\n        slides: slides\n      }, function () {\n        if (_this2.props.slideIndex !== undefined) {\n          var shiftX = _this2.calculateIndent(_this2.props.slideIndex);\n\n          if (_this2.state.shiftX === shiftX) {\n            return;\n          }\n\n          var isValidShift = _this2.state.shiftX === _this2.validateIndent(_this2.state.shiftX);\n\n          var _options$animation = options.animation,\n              animation = _options$animation === void 0 ? isValidShift : _options$animation;\n\n          _this2.setState({\n            shiftX: shiftX,\n            animation: animation\n          }, function () {\n            if (!_this2.state.animation) {\n              var _this2$props$window;\n\n              (_this2$props$window = _this2.props.window) === null || _this2$props$window === void 0 ? void 0 : _this2$props$window.requestAnimationFrame(function () {\n                return _this2.setState({\n                  animation: true\n                });\n              });\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"calcMin\",\n    value: function calcMin(_ref) {\n      var _this$viewport$offset, _this$viewport;\n\n      var containerWidth = _ref.containerWidth,\n          _ref$layerWidth = _ref.layerWidth,\n          layerWidth = _ref$layerWidth === void 0 ? 0 : _ref$layerWidth,\n          slides = _ref.slides;\n      var viewportWidth = (_this$viewport$offset = (_this$viewport = this.viewport) === null || _this$viewport === void 0 ? void 0 : _this$viewport.offsetWidth) !== null && _this$viewport$offset !== void 0 ? _this$viewport$offset : 0;\n\n      switch (this.props.align) {\n        case \"left\":\n          return containerWidth - layerWidth;\n\n        case \"right\":\n          return viewportWidth - layerWidth;\n\n        case \"center\":\n          if (this.isCenterWithCustomWidth && slides.length) {\n            var _slides = slides[slides.length - 1],\n                coordX = _slides.coordX,\n                width = _slides.width;\n            return viewportWidth / 2 - coordX - width / 2;\n          } else {\n            return viewportWidth - (containerWidth - viewportWidth) / 2 - layerWidth;\n          }\n\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"calcMax\",\n    value: function calcMax(_ref2) {\n      var _this$viewport$offset2, _this$viewport2;\n\n      var slides = _ref2.slides;\n      var viewportWidth = (_this$viewport$offset2 = (_this$viewport2 = this.viewport) === null || _this$viewport2 === void 0 ? void 0 : _this$viewport2.offsetWidth) !== null && _this$viewport$offset2 !== void 0 ? _this$viewport$offset2 : 0;\n\n      if (this.isCenterWithCustomWidth && slides.length) {\n        var _slides$ = slides[0],\n            width = _slides$.width,\n            coordX = _slides$.coordX;\n        return viewportWidth / 2 - coordX - width / 2;\n      } else {\n        return 0;\n      }\n    }\n    /*\n     * Считает отступ слоя галереи\n     */\n\n  }, {\n    key: \"calculateIndent\",\n    value: function calculateIndent(targetIndex) {\n      var slides = this.state.slides;\n\n      if (this.isFullyVisible) {\n        return 0;\n      }\n\n      var targetSlide = slides.length ? slides[targetIndex] : null;\n\n      if (targetSlide) {\n        var coordX = targetSlide.coordX,\n            width = targetSlide.width;\n\n        if (this.isCenterWithCustomWidth) {\n          var _this$viewport$offset3, _this$viewport3;\n\n          var viewportWidth = (_this$viewport$offset3 = (_this$viewport3 = this.viewport) === null || _this$viewport3 === void 0 ? void 0 : _this$viewport3.offsetWidth) !== null && _this$viewport$offset3 !== void 0 ? _this$viewport$offset3 : 0;\n          return viewportWidth / 2 - coordX - width / 2;\n        }\n\n        return this.validateIndent(-1 * coordX);\n      } else {\n        return 0;\n      }\n    }\n    /*\n     * Считает отступ слоя галереи во время драга\n     */\n\n  }, {\n    key: \"calculateDragIndent\",\n    value: function calculateDragIndent() {\n      var _this$state = this.state,\n          shiftX = _this$state.shiftX,\n          deltaX = _this$state.deltaX,\n          _this$state$min = _this$state.min,\n          min = _this$state$min === void 0 ? 0 : _this$state$min,\n          _this$state$max = _this$state.max,\n          max = _this$state$max === void 0 ? 0 : _this$state$max;\n      var indent = shiftX + deltaX;\n\n      if (indent > max) {\n        return max + Number((indent - max) / 3);\n      } else if (indent < min) {\n        return min + Number((indent - min) / 3);\n      }\n\n      return indent;\n    }\n  }, {\n    key: \"validateIndent\",\n    value: function validateIndent(value) {\n      var _this$state2 = this.state,\n          _this$state2$min = _this$state2.min,\n          min = _this$state2$min === void 0 ? 0 : _this$state2$min,\n          _this$state2$max = _this$state2.max,\n          max = _this$state2$max === void 0 ? 0 : _this$state2$max;\n\n      if (value < min) {\n        return min;\n      } else if (value > max) {\n        return max;\n      }\n\n      return value;\n    }\n  }, {\n    key: \"isFullyVisible\",\n    get: function get() {\n      var _this$state$layerWidt;\n\n      return ((_this$state$layerWidt = this.state.layerWidth) !== null && _this$state$layerWidt !== void 0 ? _this$state$layerWidt : 0) <= this.state.containerWidth;\n    }\n    /*\n     * Получает индекс слайда, к которому будет осуществлен переход\n     */\n\n  }, {\n    key: \"getTarget\",\n    value: function getTarget(e) {\n      var _this$state3 = this.state,\n          slides = _this$state3.slides,\n          deltaX = _this$state3.deltaX,\n          shiftX = _this$state3.shiftX,\n          _this$state3$max = _this$state3.max,\n          max = _this$state3$max === void 0 ? 0 : _this$state3$max;\n      var _this$props$slideInde2 = this.props.slideIndex,\n          slideIndex = _this$props$slideInde2 === void 0 ? 0 : _this$props$slideInde2;\n      var expectDeltaX = deltaX / e.duration * 240 * 0.6;\n      var shift = shiftX + deltaX + expectDeltaX - max;\n      var direction = deltaX < 0 ? 1 : -1; // Находим ближайшую границу слайда к текущему отступу\n\n      var targetIndex = slides.reduce(function (val, item, index) {\n        var previousValue = Math.abs(slides[val].coordX + shift);\n        var currentValue = Math.abs(item.coordX + shift);\n        return previousValue < currentValue ? val : index;\n      }, slideIndex);\n\n      if (targetIndex === slideIndex) {\n        var targetSlide = slideIndex + direction;\n\n        if (targetSlide >= 0 && targetSlide < slides.length) {\n          if (Math.abs(deltaX) > slides[targetSlide].width * 0.05) {\n            targetIndex = targetSlide;\n          }\n        }\n      }\n\n      return targetIndex;\n    }\n  }, {\n    key: \"canSlideLeft\",\n    get: function get() {\n      // shiftX is negative number <= 0, we can swipe back only if it is < 0\n      return !this.isFullyVisible && this.state.shiftX < 0;\n    }\n  }, {\n    key: \"canSlideRight\",\n    get: function get() {\n      var _this$state4 = this.state,\n          containerWidth = _this$state4.containerWidth,\n          _this$state4$layerWid = _this$state4.layerWidth,\n          layerWidth = _this$state4$layerWid === void 0 ? 0 : _this$state4$layerWid,\n          shiftX = _this$state4.shiftX,\n          slides = _this$state4.slides;\n      var _this$props4 = this.props,\n          align = _this$props4.align,\n          _this$props4$slideInd = _this$props4.slideIndex,\n          slideIndex = _this$props4$slideInd === void 0 ? 0 : _this$props4$slideInd;\n      return !this.isFullyVisible && ( // we can't move right when gallery layer fully scrolled right, if gallery aligned by left side\n      align === \"left\" && containerWidth - shiftX < layerWidth || // otherwise we need to check current slide index (align = right or align = center)\n      align !== \"left\" && slideIndex < slides.length - 1);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.initializeSlides({\n        animation: false\n      });\n      this.props.window.addEventListener(\"resize\", this.onResize);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var widthChanged = this.props.slideWidth !== prevProps.slideWidth;\n      var isPropUpdate = this.props !== prevProps;\n      var slideCountChanged = React.Children.count(this.props.children) !== React.Children.count(prevProps.children);\n      var isCustomWidth = this.props.slideWidth === \"custom\"; // в любом из этих случаев позиция могла поменяться\n\n      if (widthChanged || slideCountChanged || isCustomWidth && isPropUpdate) {\n        this.initializeSlides();\n      } else if (this.props.slideIndex !== prevProps.slideIndex) {\n        var _this$props$slideInde3;\n\n        this.setState({\n          animation: true,\n          deltaX: 0,\n          shiftX: this.calculateIndent((_this$props$slideInde3 = this.props.slideIndex) !== null && _this$props$slideInde3 !== void 0 ? _this$props$slideInde3 : 0)\n        });\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.props.window.removeEventListener(\"resize\", this.onResize);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var _this$state5 = this.state,\n          animation = _this$state5.animation,\n          duration = _this$state5.duration,\n          dragging = _this$state5.dragging;\n\n      var _this$props5 = this.props,\n          children = _this$props5.children,\n          slideWidth = _this$props5.slideWidth,\n          _this$props5$slideInd = _this$props5.slideIndex,\n          slideIndex = _this$props5$slideInd === void 0 ? 0 : _this$props5$slideInd,\n          isDraggable = _this$props5.isDraggable,\n          onDragStart = _this$props5.onDragStart,\n          onDragEnd = _this$props5.onDragEnd,\n          onChange = _this$props5.onChange,\n          onEnd = _this$props5.onEnd,\n          align = _this$props5.align,\n          bullets = _this$props5.bullets,\n          platform = _this$props5.platform,\n          hasMouse = _this$props5.hasMouse,\n          showArrows = _this$props5.showArrows,\n          window = _this$props5.window,\n          document = _this$props5.document,\n          getRef = _this$props5.getRef,\n          getRootRef = _this$props5.getRootRef,\n          restProps = _objectWithoutProperties(_this$props5, _excluded);\n\n      var indent = dragging ? this.calculateDragIndent() : this.calculateIndent(slideIndex);\n      var layerStyle = {\n        WebkitTransform: \"translateX(\".concat(indent, \"px)\"),\n        transform: \"translateX(\".concat(indent, \"px)\"),\n        WebkitTransition: animation ? \"-webkit-transform \".concat(duration, \"s cubic-bezier(.1, 0, .25, 1)\") : \"none\",\n        transition: animation ? \"transform \".concat(duration, \"s cubic-bezier(.1, 0, .25, 1)\") : \"none\"\n      };\n      return createScopedElement(\"div\", _extends({}, restProps, {\n        vkuiClass: classNames(getClassName(\"Gallery\", platform), \"Gallery--\".concat(align), {\n          \"Gallery--dragging\": dragging,\n          \"Gallery--custom-width\": slideWidth === \"custom\"\n        }),\n        ref: this.getRootRef\n      }), createScopedElement(Touch, {\n        vkuiClass: \"Gallery__viewport\",\n        onStartX: this.onStart,\n        onMoveX: this.onMoveX,\n        onEnd: this.onEnd,\n        noSlideClick: true,\n        style: {\n          width: slideWidth === \"custom\" ? \"100%\" : slideWidth\n        },\n        getRootRef: this.getViewportRef\n      }, createScopedElement(\"div\", {\n        vkuiClass: \"Gallery__layer\",\n        style: layerStyle\n      }, React.Children.map(children, function (item, i) {\n        return createScopedElement(\"div\", {\n          vkuiClass: \"Gallery__slide\",\n          key: \"slide-\".concat(i),\n          ref: _this3.getSlideRef(i)\n        }, item);\n      }))), bullets && createScopedElement(\"div\", {\n        \"aria-hidden\": \"true\",\n        vkuiClass: classNames(\"Gallery__bullets\", \"Gallery__bullets--\".concat(bullets))\n      }, React.Children.map(children, function (_item, index) {\n        return createScopedElement(\"div\", {\n          vkuiClass: classNames(\"Gallery__bullet\", {\n            \"Gallery__bullet--active\": index === slideIndex\n          }),\n          key: index\n        });\n      })), showArrows && hasMouse && this.canSlideLeft && createScopedElement(HorizontalScrollArrow, {\n        direction: \"left\",\n        onClick: this.slideLeft\n      }), showArrows && hasMouse && this.canSlideRight && createScopedElement(HorizontalScrollArrow, {\n        direction: \"right\",\n        onClick: this.slideRight\n      }));\n    }\n  }]);\n\n  return BaseGallery;\n}(React.Component);\n\n_defineProperty(BaseGallery, \"defaultProps\", {\n  slideWidth: \"100%\",\n  children: \"\",\n  align: \"left\",\n  bullets: false,\n  isDraggable: true\n});\n\nvar BaseGalleryAdaptive = withAdaptivity(withDOM(BaseGallery), {\n  hasMouse: true\n});\n\nvar Gallery = function Gallery(_ref3) {\n  var _props$slideIndex;\n\n  var _ref3$initialSlideInd = _ref3.initialSlideIndex,\n      initialSlideIndex = _ref3$initialSlideInd === void 0 ? 0 : _ref3$initialSlideInd,\n      children = _ref3.children,\n      _ref3$timeout = _ref3.timeout,\n      timeout = _ref3$timeout === void 0 ? 0 : _ref3$timeout,\n      onChange = _ref3.onChange,\n      props = _objectWithoutProperties(_ref3, _excluded2);\n\n  var _React$useState = React.useState(initialSlideIndex),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      localSlideIndex = _React$useState2[0],\n      setSlideIndex = _React$useState2[1];\n\n  var isControlled = typeof props.slideIndex === \"number\";\n  var slideIndex = isControlled ? (_props$slideIndex = props.slideIndex) !== null && _props$slideIndex !== void 0 ? _props$slideIndex : 0 : localSlideIndex;\n  var isDraggable = !isControlled || Boolean(onChange);\n  var slides = React.Children.toArray(children).filter(function (item) {\n    return Boolean(item);\n  });\n  var childCount = slides.length;\n  var handleChange = React.useCallback(function (current) {\n    if (current === slideIndex) {\n      return;\n    }\n\n    !isControlled && setSlideIndex(current);\n    onChange && onChange(current);\n  }, [isControlled, onChange, slideIndex]);\n  var autoplay = useTimeout(function () {\n    return handleChange((slideIndex + 1) % childCount);\n  }, timeout);\n  React.useEffect(function () {\n    return timeout ? autoplay.set() : autoplay.clear();\n  }, [timeout, slideIndex, autoplay]); // prevent invalid slideIndex\n  // any slide index is invalid with no slides, just keep it as is\n\n  var safeSlideIndex = childCount > 0 ? clamp(slideIndex, 0, childCount - 1) : slideIndex; // notify parent in controlled mode\n\n  React.useEffect(function () {\n    if (onChange && safeSlideIndex !== slideIndex) {\n      onChange(safeSlideIndex);\n    }\n  }, [onChange, safeSlideIndex, slideIndex]);\n  return createScopedElement(BaseGalleryAdaptive, _extends({\n    isDraggable: isDraggable\n  }, props, {\n    slideIndex: safeSlideIndex,\n    onChange: handleChange\n  }), slides);\n}; // eslint-disable-next-line import/no-default-export\n\n\nexport default withPlatform(Gallery);","map":{"version":3,"mappings":"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","names":["React","getClassName","Touch","classNames","withPlatform","withDOM","setRef","withAdaptivity","HorizontalScrollArrow","clamp","useTimeout","BaseGallery","props","_classCallCheck","_this","_defineProperty","setState","animation","e","isDraggable","isFullyVisible","originalEvent","preventDefault","isSlideX","onDragStart","state","deltaX","shiftX","dragging","targetIndex","isSlide","getTarget","slideIndex","onDragEnd","onChange","_this$props$onChange","onEnd","initializeSlides","canSlideLeft","canSlideRight","id","slide","slidesStore","viewport","getRef","container","getRootRef","containerWidth","slides","duration","slideWidth","align","options","Children","map","children","_item","i","elem","_this2","coordX","offsetLeft","width","offsetWidth","_this$container","layerWidth","reduce","val","min","calcMin","max","calcMax","undefined","calculateIndent","isValidShift","validateIndent","window","requestAnimationFrame","viewportWidth","_this$viewport","isCenterWithCustomWidth","length","_this$viewport2","targetSlide","_this$viewport3","indent","Number","value","expectDeltaX","shift","direction","item","index","previousValue","Math","abs","currentValue","addEventListener","onResize","prevProps","widthChanged","isPropUpdate","slideCountChanged","count","isCustomWidth","removeEventListener","bullets","platform","hasMouse","showArrows","document","restProps","calculateDragIndent","layerStyle","WebkitTransform","transform","WebkitTransition","transition","createScopedElement","vkuiClass","ref","onStartX","onStart","onMoveX","noSlideClick","style","getViewportRef","key","_this3","getSlideRef","onClick","slideLeft","slideRight","Component","BaseGalleryAdaptive","Gallery","initialSlideIndex","timeout","useState","localSlideIndex","setSlideIndex","isControlled","Boolean","toArray","filter","childCount","handleChange","useCallback","current","autoplay","useEffect","set","clear","safeSlideIndex"],"sources":["/Users/al.balandin/code/vkvideo-test/node_modules/@vkontakte/vkui/src/components/Gallery/Gallery.tsx"],"sourcesContent":["import * as React from \"react\";\nimport { getClassName } from \"../../helpers/getClassName\";\nimport { Touch, TouchEventHandler, TouchEvent } from \"../Touch/Touch\";\nimport { classNames } from \"../../lib/classNames\";\nimport { withPlatform } from \"../../hoc/withPlatform\";\nimport { HasAlign, HasPlatform, HasRef, HasRootRef } from \"../../types\";\nimport { withDOM, DOMProps } from \"../../lib/dom\";\nimport { setRef } from \"../../lib/utils\";\nimport { withAdaptivity, AdaptivityProps } from \"../../hoc/withAdaptivity\";\nimport HorizontalScrollArrow from \"../HorizontalScroll/HorizontalScrollArrow\";\nimport { clamp } from \"../../helpers/math\";\nimport { useTimeout } from \"../../hooks/useTimeout\";\nimport \"./Gallery.css\";\n\nexport interface BaseGalleryProps\n  extends Omit<\n      React.HTMLAttributes<HTMLDivElement>,\n      \"onChange\" | \"onDragStart\" | \"onDragEnd\"\n    >,\n    HasPlatform,\n    HasAlign,\n    HasRootRef<HTMLDivElement>,\n    HasRef<HTMLElement> {\n  slideWidth?: string | number;\n  slideIndex?: number;\n  onDragStart?: TouchEventHandler;\n  onDragEnd?: TouchEventHandler;\n  onChange?(current: number): void;\n  onEnd?({ targetIndex }: { targetIndex: number }): void;\n  bullets?: \"dark\" | \"light\" | false;\n  isDraggable?: boolean;\n  showArrows?: boolean;\n}\n\nexport interface GalleryProps extends BaseGalleryProps {\n  initialSlideIndex?: number;\n  timeout?: number;\n}\n\nexport interface GalleryState {\n  containerWidth: number;\n  layerWidth?: number;\n  min?: number;\n  max?: number;\n  deltaX: number;\n  shiftX: number;\n  slides: GallerySlidesState[];\n  animation: boolean;\n  duration: number;\n  dragging?: boolean;\n}\n\nexport interface GallerySlidesState {\n  coordX: number;\n  width: number;\n}\n\ntype GetSlideRef = (index: number) => React.RefCallback<HTMLElement>;\n\nclass BaseGallery extends React.Component<\n  BaseGalleryProps & DOMProps & AdaptivityProps,\n  GalleryState\n> {\n  constructor(props: GalleryProps) {\n    super(props);\n\n    this.state = {\n      containerWidth: 0,\n      deltaX: 0,\n      shiftX: 0,\n      slides: [],\n      animation: true,\n      duration: 0.24,\n    };\n\n    this.slidesStore = {};\n  }\n\n  container: HTMLDivElement | null = null;\n  slidesStore: {\n    [index: string]: HTMLElement | null;\n  };\n  viewport: HTMLElement | null = null;\n\n  static defaultProps: Partial<BaseGalleryProps> = {\n    slideWidth: \"100%\",\n    children: \"\",\n    align: \"left\",\n    bullets: false,\n    isDraggable: true,\n  };\n\n  get isCenterWithCustomWidth() {\n    return this.props.slideWidth === \"custom\" && this.props.align === \"center\";\n  }\n\n  initializeSlides(options: { animation?: boolean } = {}) {\n    const slides =\n      React.Children.map(\n        this.props.children,\n        (_item: React.ReactNode, i: number): GallerySlidesState => {\n          const elem = this.slidesStore[`slide-${i}`];\n          return {\n            coordX: elem?.offsetLeft ?? 0,\n            width: elem?.offsetWidth ?? 0,\n          };\n        }\n      ) ?? [];\n\n    const containerWidth = this.container?.offsetWidth ?? 0;\n    const layerWidth = slides.reduce(\n      (val: number, slide: GallerySlidesState) => slide.width + val,\n      0\n    );\n\n    const min = this.calcMin({ containerWidth, layerWidth, slides });\n    const max = this.calcMax({ slides });\n\n    this.setState({ min, max, layerWidth, containerWidth, slides }, () => {\n      if (this.props.slideIndex !== undefined) {\n        const shiftX = this.calculateIndent(this.props.slideIndex);\n        if (this.state.shiftX === shiftX) {\n          return;\n        }\n        const isValidShift =\n          this.state.shiftX === this.validateIndent(this.state.shiftX);\n        const { animation = isValidShift } = options;\n        this.setState({ shiftX, animation }, () => {\n          if (!this.state.animation) {\n            this.props.window?.requestAnimationFrame(() =>\n              this.setState({ animation: true })\n            );\n          }\n        });\n      }\n    });\n  }\n\n  calcMin({\n    containerWidth,\n    layerWidth = 0,\n    slides,\n  }: Pick<GalleryState, \"containerWidth\" | \"layerWidth\" | \"slides\">) {\n    const viewportWidth = this.viewport?.offsetWidth ?? 0;\n    switch (this.props.align) {\n      case \"left\":\n        return containerWidth - layerWidth;\n      case \"right\":\n        return viewportWidth - layerWidth;\n      case \"center\":\n        if (this.isCenterWithCustomWidth && slides.length) {\n          const { coordX, width } = slides[slides.length - 1];\n          return viewportWidth / 2 - coordX - width / 2;\n        } else {\n          return (\n            viewportWidth - (containerWidth - viewportWidth) / 2 - layerWidth\n          );\n        }\n    }\n    return undefined;\n  }\n\n  calcMax({ slides }: Pick<GalleryState, \"slides\">) {\n    const viewportWidth = this.viewport?.offsetWidth ?? 0;\n    if (this.isCenterWithCustomWidth && slides.length) {\n      const { width, coordX } = slides[0];\n      return viewportWidth / 2 - coordX - width / 2;\n    } else {\n      return 0;\n    }\n  }\n\n  /*\n   * Считает отступ слоя галереи\n   */\n  calculateIndent(targetIndex: number) {\n    const { slides } = this.state;\n\n    if (this.isFullyVisible) {\n      return 0;\n    }\n\n    const targetSlide = slides.length ? slides[targetIndex] : null;\n\n    if (targetSlide) {\n      const { coordX, width } = targetSlide;\n\n      if (this.isCenterWithCustomWidth) {\n        const viewportWidth = this.viewport?.offsetWidth ?? 0;\n        return viewportWidth / 2 - coordX - width / 2;\n      }\n\n      return this.validateIndent(-1 * coordX);\n    } else {\n      return 0;\n    }\n  }\n\n  /*\n   * Считает отступ слоя галереи во время драга\n   */\n  calculateDragIndent() {\n    const { shiftX, deltaX, min = 0, max = 0 } = this.state;\n    const indent = shiftX + deltaX;\n\n    if (indent > max) {\n      return max + Number((indent - max) / 3);\n    } else if (indent < min) {\n      return min + Number((indent - min) / 3);\n    }\n\n    return indent;\n  }\n\n  validateIndent(value: number) {\n    const { min = 0, max = 0 } = this.state;\n\n    if (value < min) {\n      return min;\n    } else if (value > max) {\n      return max;\n    }\n\n    return value;\n  }\n\n  get isFullyVisible() {\n    return (this.state.layerWidth ?? 0) <= this.state.containerWidth;\n  }\n\n  /*\n   * Получает индекс слайда, к которому будет осуществлен переход\n   */\n  getTarget(e: TouchEvent) {\n    const { slides, deltaX, shiftX, max = 0 } = this.state;\n    const { slideIndex = 0 } = this.props;\n    const expectDeltaX = (deltaX / e.duration) * 240 * 0.6;\n    const shift = shiftX + deltaX + expectDeltaX - max;\n    const direction = deltaX < 0 ? 1 : -1;\n\n    // Находим ближайшую границу слайда к текущему отступу\n    let targetIndex = slides.reduce(\n      (val: number, item: GallerySlidesState, index: number) => {\n        const previousValue = Math.abs(slides[val].coordX + shift);\n        const currentValue = Math.abs(item.coordX + shift);\n\n        return previousValue < currentValue ? val : index;\n      },\n      slideIndex\n    );\n\n    if (targetIndex === slideIndex) {\n      let targetSlide = slideIndex + direction;\n\n      if (targetSlide >= 0 && targetSlide < slides.length) {\n        if (Math.abs(deltaX) > slides[targetSlide].width * 0.05) {\n          targetIndex = targetSlide;\n        }\n      }\n    }\n\n    return targetIndex;\n  }\n\n  onStart: TouchEventHandler = () => {\n    this.setState({\n      animation: false,\n    });\n  };\n\n  onMoveX: TouchEventHandler = (e: TouchEvent) => {\n    if (this.props.isDraggable && !this.isFullyVisible) {\n      e.originalEvent.preventDefault();\n\n      if (e.isSlideX) {\n        this.props.onDragStart && this.props.onDragStart(e);\n\n        if (\n          this.state.deltaX !== e.shiftX ||\n          this.state.dragging !== e.isSlideX\n        ) {\n          this.setState({\n            deltaX: e.shiftX,\n            dragging: e.isSlideX,\n          });\n        }\n      }\n    }\n  };\n\n  onEnd: TouchEventHandler = (e: TouchEvent) => {\n    const targetIndex = e.isSlide\n      ? this.getTarget(e)\n      : this.props.slideIndex ?? 0;\n    this.props.onDragEnd && this.props.onDragEnd(e);\n    this.setState({ deltaX: 0, animation: true }, () =>\n      this.props.onChange?.(targetIndex)\n    );\n\n    if (this.props.onEnd) {\n      this.props.onEnd({ targetIndex });\n    }\n  };\n\n  onResize: VoidFunction = () => this.initializeSlides({ animation: false });\n\n  get canSlideLeft() {\n    // shiftX is negative number <= 0, we can swipe back only if it is < 0\n    return !this.isFullyVisible && this.state.shiftX < 0;\n  }\n\n  get canSlideRight() {\n    const { containerWidth, layerWidth = 0, shiftX, slides } = this.state;\n    const { align, slideIndex = 0 } = this.props;\n    return (\n      !this.isFullyVisible &&\n      // we can't move right when gallery layer fully scrolled right, if gallery aligned by left side\n      ((align === \"left\" && containerWidth - shiftX < layerWidth) ||\n        // otherwise we need to check current slide index (align = right or align = center)\n        (align !== \"left\" && slideIndex < slides.length - 1))\n    );\n  }\n\n  slideLeft = () => {\n    const { slideIndex = 0, onChange } = this.props;\n    if (this.canSlideLeft) {\n      this.setState({ deltaX: 0, animation: true }, () =>\n        onChange?.(slideIndex - 1)\n      );\n    }\n  };\n\n  slideRight = () => {\n    const { slideIndex = 0, onChange } = this.props;\n    if (this.canSlideRight) {\n      this.setState({ deltaX: 0, animation: true }, () =>\n        onChange?.(slideIndex + 1)\n      );\n    }\n  };\n\n  getSlideRef: GetSlideRef = (id: number) => (slide) => {\n    this.slidesStore[`slide-${id}`] = slide;\n  };\n\n  getViewportRef: React.RefCallback<HTMLElement> = (viewport) => {\n    this.viewport = viewport;\n    if (this.props.getRef) {\n      setRef(viewport, this.props.getRef);\n    }\n  };\n\n  getRootRef: React.RefCallback<HTMLDivElement> = (container) => {\n    this.container = container;\n    if (this.props.getRootRef) {\n      setRef(container, this.props.getRootRef);\n    }\n  };\n\n  componentDidMount() {\n    this.initializeSlides({ animation: false });\n    this.props.window!.addEventListener(\"resize\", this.onResize);\n  }\n\n  componentDidUpdate(prevProps: GalleryProps) {\n    const widthChanged = this.props.slideWidth !== prevProps.slideWidth;\n    const isPropUpdate = this.props !== prevProps;\n    const slideCountChanged =\n      React.Children.count(this.props.children) !==\n      React.Children.count(prevProps.children);\n    const isCustomWidth = this.props.slideWidth === \"custom\";\n\n    // в любом из этих случаев позиция могла поменяться\n    if (widthChanged || slideCountChanged || (isCustomWidth && isPropUpdate)) {\n      this.initializeSlides();\n    } else if (this.props.slideIndex !== prevProps.slideIndex) {\n      this.setState({\n        animation: true,\n        deltaX: 0,\n        shiftX: this.calculateIndent(this.props.slideIndex ?? 0),\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    this.props.window!.removeEventListener(\"resize\", this.onResize);\n  }\n\n  render() {\n    const { animation, duration, dragging } = this.state;\n    const {\n      children,\n      slideWidth,\n      slideIndex = 0,\n      isDraggable,\n      onDragStart,\n      onDragEnd,\n      onChange,\n      onEnd,\n      align,\n      bullets,\n      platform,\n      hasMouse,\n      showArrows,\n      window,\n      document,\n      getRef,\n      getRootRef,\n      ...restProps\n    } = this.props;\n\n    const indent = dragging\n      ? this.calculateDragIndent()\n      : this.calculateIndent(slideIndex);\n\n    const layerStyle = {\n      WebkitTransform: `translateX(${indent}px)`,\n      transform: `translateX(${indent}px)`,\n      WebkitTransition: animation\n        ? `-webkit-transform ${duration}s cubic-bezier(.1, 0, .25, 1)`\n        : \"none\",\n      transition: animation\n        ? `transform ${duration}s cubic-bezier(.1, 0, .25, 1)`\n        : \"none\",\n    };\n\n    return (\n      <div\n        {...restProps}\n        vkuiClass={classNames(\n          getClassName(\"Gallery\", platform),\n          `Gallery--${align}`,\n          {\n            \"Gallery--dragging\": dragging,\n            \"Gallery--custom-width\": slideWidth === \"custom\",\n          }\n        )}\n        ref={this.getRootRef}\n      >\n        <Touch\n          vkuiClass=\"Gallery__viewport\"\n          onStartX={this.onStart}\n          onMoveX={this.onMoveX}\n          onEnd={this.onEnd}\n          noSlideClick\n          style={{ width: slideWidth === \"custom\" ? \"100%\" : slideWidth }}\n          getRootRef={this.getViewportRef}\n        >\n          <div vkuiClass=\"Gallery__layer\" style={layerStyle}>\n            {React.Children.map(\n              children,\n              (item: React.ReactNode, i: number) => (\n                <div\n                  vkuiClass=\"Gallery__slide\"\n                  key={`slide-${i}`}\n                  ref={this.getSlideRef(i)}\n                >\n                  {item}\n                </div>\n              )\n            )}\n          </div>\n        </Touch>\n\n        {bullets && (\n          <div\n            aria-hidden=\"true\"\n            vkuiClass={classNames(\n              \"Gallery__bullets\",\n              `Gallery__bullets--${bullets}`\n            )}\n          >\n            {React.Children.map(\n              children,\n              (_item: React.ReactNode, index: number) => (\n                <div\n                  vkuiClass={classNames(\"Gallery__bullet\", {\n                    \"Gallery__bullet--active\": index === slideIndex,\n                  })}\n                  key={index}\n                />\n              )\n            )}\n          </div>\n        )}\n\n        {showArrows && hasMouse && this.canSlideLeft && (\n          <HorizontalScrollArrow direction=\"left\" onClick={this.slideLeft} />\n        )}\n        {showArrows && hasMouse && this.canSlideRight && (\n          <HorizontalScrollArrow direction=\"right\" onClick={this.slideRight} />\n        )}\n      </div>\n    );\n  }\n}\n\nconst BaseGalleryAdaptive = withAdaptivity(withDOM(BaseGallery), {\n  hasMouse: true,\n});\n\nconst Gallery: React.FC<GalleryProps> = ({\n  initialSlideIndex = 0,\n  children,\n  timeout = 0,\n  onChange,\n  ...props\n}: GalleryProps) => {\n  const [localSlideIndex, setSlideIndex] = React.useState(initialSlideIndex);\n  const isControlled = typeof props.slideIndex === \"number\";\n  const slideIndex = isControlled ? props.slideIndex ?? 0 : localSlideIndex;\n  const isDraggable = !isControlled || Boolean(onChange);\n  const slides = React.Children.toArray(children).filter((item) =>\n    Boolean(item)\n  );\n  const childCount = slides.length;\n\n  const handleChange: GalleryProps[\"onChange\"] = React.useCallback(\n    (current) => {\n      if (current === slideIndex) {\n        return;\n      }\n      !isControlled && setSlideIndex(current);\n      onChange && onChange(current);\n    },\n    [isControlled, onChange, slideIndex]\n  );\n\n  const autoplay = useTimeout(\n    () => handleChange((slideIndex + 1) % childCount),\n    timeout\n  );\n  React.useEffect(\n    () => (timeout ? autoplay.set() : autoplay.clear()),\n    [timeout, slideIndex, autoplay]\n  );\n\n  // prevent invalid slideIndex\n  // any slide index is invalid with no slides, just keep it as is\n  const safeSlideIndex =\n    childCount > 0 ? clamp(slideIndex, 0, childCount - 1) : slideIndex;\n  // notify parent in controlled mode\n  React.useEffect(() => {\n    if (onChange && safeSlideIndex !== slideIndex) {\n      onChange(safeSlideIndex);\n    }\n  }, [onChange, safeSlideIndex, slideIndex]);\n\n  return (\n    <BaseGalleryAdaptive\n      isDraggable={isDraggable}\n      {...props}\n      slideIndex={safeSlideIndex}\n      onChange={handleChange}\n    >\n      {slides}\n    </BaseGalleryAdaptive>\n  );\n};\n\n// eslint-disable-next-line import/no-default-export\nexport default withPlatform(Gallery);\n"]},"metadata":{},"sourceType":"module"}