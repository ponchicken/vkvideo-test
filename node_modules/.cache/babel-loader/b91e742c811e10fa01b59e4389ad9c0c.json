{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"min\", \"max\", \"step\", \"value\", \"defaultValue\", \"onChange\", \"getRootRef\", \"sizeY\", \"disabled\"];\nimport { createScopedElement } from \"../../lib/jsxRuntime\";\nimport * as React from \"react\";\nimport { Touch } from \"../Touch/Touch\";\nimport { getClassName } from \"../../helpers/getClassName\";\nimport { classNames } from \"../../lib/classNames\";\nimport { rescale } from \"../../helpers/math\";\nimport { withAdaptivity } from \"../../hoc/withAdaptivity\";\nimport { useExternRef } from \"../../hooks/useExternRef\";\nimport { usePlatform } from \"../../hooks/usePlatform\";\n\nvar UniversalSliderDumb = function UniversalSliderDumb(_ref) {\n  var _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 0 : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 100 : _ref$max,\n      step = _ref.step,\n      _ref$value = _ref.value,\n      value = _ref$value === void 0 ? [0, 0] : _ref$value,\n      defaultValue = _ref.defaultValue,\n      onChange = _ref.onChange,\n      getRootRef = _ref.getRootRef,\n      sizeY = _ref.sizeY,\n      disabled = _ref.disabled,\n      restProps = _objectWithoutProperties(_ref, _excluded);\n\n  var platform = usePlatform();\n\n  var _value = _slicedToArray(value, 2),\n      start = _value[0],\n      end = _value[1];\n\n  var isRange = start != null;\n  var gesture = React.useRef({\n    dragging: false,\n    startX: 0,\n    containerWidth: 0\n  }).current;\n  var container = useExternRef(getRootRef);\n  var thumbStart = React.useRef(null);\n  var thumbEnd = React.useRef(null);\n\n  var offsetToValue = function offsetToValue(absolute) {\n    return rescale(absolute, [0, gesture.containerWidth], [min, max], {\n      step: step\n    });\n  };\n\n  var updateRange = function updateRange(nextValue) {\n    if (start == null) {\n      return [null, nextValue];\n    }\n\n    var dragging = gesture.dragging;\n\n    if (dragging === \"start\") {\n      if (nextValue > end) {\n        // \"перехватиться\", если перетянули за конец\n        gesture.dragging = \"end\";\n        return [end, nextValue];\n      }\n\n      return [nextValue, end];\n    }\n\n    if (dragging === \"end\") {\n      if (nextValue < start) {\n        // \"перехватиться\", если перетянули за начало\n        gesture.dragging = \"start\";\n        return [nextValue, start];\n      }\n\n      return [start, nextValue];\n    }\n\n    return value;\n  };\n\n  var snapDirection = function snapDirection(pos, target) {\n    if (target === thumbStart.current) {\n      return \"start\";\n    }\n\n    if (target === thumbEnd.current) {\n      return \"end\";\n    }\n\n    return Math.abs((start !== null && start !== void 0 ? start : 0) - pos) <= Math.abs(end - pos) ? \"start\" : \"end\";\n  };\n\n  var onStart = function onStart(e) {\n    var _container$current, _boundingRect$width, _boundingRect$left;\n\n    var boundingRect = (_container$current = container.current) === null || _container$current === void 0 ? void 0 : _container$current.getBoundingClientRect();\n    gesture.containerWidth = (_boundingRect$width = boundingRect === null || boundingRect === void 0 ? void 0 : boundingRect.width) !== null && _boundingRect$width !== void 0 ? _boundingRect$width : 0;\n    var absolutePosition = e.startX - ((_boundingRect$left = boundingRect === null || boundingRect === void 0 ? void 0 : boundingRect.left) !== null && _boundingRect$left !== void 0 ? _boundingRect$left : 0);\n    var pos = offsetToValue(absolutePosition);\n    gesture.dragging = snapDirection(pos, e.originalEvent.target);\n    gesture.startX = absolutePosition;\n    onChange === null || onChange === void 0 ? void 0 : onChange(updateRange(pos), e);\n    e.originalEvent.stopPropagation();\n  };\n\n  var onMove = function onMove(e) {\n    onChange === null || onChange === void 0 ? void 0 : onChange(updateRange(offsetToValue(gesture.startX + (e.shiftX || 0))), e);\n    e.originalEvent.stopPropagation();\n    e.originalEvent.preventDefault();\n  };\n\n  var onEnd = function onEnd(e) {\n    gesture.dragging = false;\n    e.originalEvent.stopPropagation();\n  };\n\n  var toPercent = function toPercent(v) {\n    return (v - min) / (max - min) * 100;\n  };\n\n  var draggerStyle = isRange ? {\n    width: \"\".concat(toPercent(end) - toPercent(start !== null && start !== void 0 ? start : 0), \"%\"),\n    left: \"\".concat(toPercent(start !== null && start !== void 0 ? start : 0), \"%\")\n  } : {\n    width: \"\".concat(toPercent(end), \"%\")\n  };\n  return createScopedElement(Touch, _extends({\n    \"data-value\": isRange ? value.join(\",\") : value\n  }, restProps, disabled ? {} : {\n    onStart: onStart,\n    onMove: onMove,\n    onEnd: onEnd\n  }, {\n    vkuiClass: classNames(getClassName(\"Slider\", platform), \"Slider--sizeY-\".concat(sizeY), disabled && \"Slider--disabled\")\n  }), createScopedElement(\"div\", {\n    ref: container,\n    vkuiClass: \"Slider__in\"\n  }, createScopedElement(\"div\", {\n    vkuiClass: \"Slider__dragger\",\n    style: draggerStyle\n  }, isRange && createScopedElement(\"span\", {\n    vkuiClass: classNames(\"Slider__thumb\", \"Slider__thumb--start\"),\n    ref: thumbStart\n  }), createScopedElement(\"span\", {\n    vkuiClass: classNames(\"Slider__thumb\", \"Slider__thumb--end\"),\n    ref: thumbEnd\n  }))));\n};\n\nexport var UniversalSlider = withAdaptivity(UniversalSliderDumb, {\n  sizeY: true\n});","map":{"version":3,"mappings":"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","names":["React","Touch","getClassName","classNames","rescale","withAdaptivity","useExternRef","usePlatform","UniversalSliderDumb","min","max","step","value","defaultValue","onChange","getRootRef","sizeY","disabled","restProps","platform","start","end","isRange","gesture","useRef","dragging","startX","containerWidth","current","container","thumbStart","thumbEnd","offsetToValue","absolute","updateRange","nextValue","snapDirection","pos","target","Math","abs","onStart","e","boundingRect","_container$current","getBoundingClientRect","width","absolutePosition","left","originalEvent","stopPropagation","onMove","shiftX","preventDefault","onEnd","toPercent","v","draggerStyle","createScopedElement","join","vkuiClass","ref","style","UniversalSlider"],"sources":["/Users/al.balandin/code/vkvideo-test/node_modules/@vkontakte/vkui/src/components/RangeSlider/UniversalSlider.tsx"],"sourcesContent":["import * as React from \"react\";\nimport { Touch, TouchEvent, TouchEventHandler } from \"../Touch/Touch\";\nimport { getClassName } from \"../../helpers/getClassName\";\nimport { classNames } from \"../../lib/classNames\";\nimport { HasRootRef } from \"../../types\";\nimport { rescale } from \"../../helpers/math\";\nimport { withAdaptivity, AdaptivityProps } from \"../../hoc/withAdaptivity\";\nimport { useExternRef } from \"../../hooks/useExternRef\";\nimport { usePlatform } from \"../../hooks/usePlatform\";\nimport \"../Slider/Slider.css\";\n\nexport type UniversalValue = [number | null, number];\n\nexport interface UniversalSliderProps<Value>\n  extends HasRootRef<HTMLDivElement>,\n    Omit<\n      React.HTMLAttributes<HTMLDivElement>,\n      \"value\" | \"defaultValue\" | \"onChange\"\n    >,\n    AdaptivityProps {\n  min?: number;\n  max?: number;\n  step?: number;\n  value?: Value;\n  defaultValue?: Value;\n  disabled?: boolean;\n  onChange?(value: Value, e: TouchEvent): void;\n}\n\nconst UniversalSliderDumb: React.FC<UniversalSliderProps<UniversalValue>> = ({\n  min = 0,\n  max = 100,\n  step,\n  value = [0, 0],\n  defaultValue,\n  onChange,\n  getRootRef,\n  sizeY,\n  disabled,\n  ...restProps\n}) => {\n  const platform = usePlatform();\n  const [start, end] = value;\n  const isRange = start != null;\n  const gesture = React.useRef({\n    dragging: false as false | \"start\" | \"end\",\n    startX: 0,\n    containerWidth: 0,\n  }).current;\n  const container = useExternRef(getRootRef);\n  const thumbStart = React.useRef<HTMLDivElement>(null);\n  const thumbEnd = React.useRef<HTMLDivElement>(null);\n\n  const offsetToValue = (absolute: number) => {\n    return rescale(absolute, [0, gesture.containerWidth], [min, max], { step });\n  };\n\n  const updateRange = (nextValue: number): UniversalValue => {\n    if (start == null) {\n      return [null, nextValue];\n    }\n\n    const { dragging } = gesture;\n    if (dragging === \"start\") {\n      if (nextValue > end) {\n        // \"перехватиться\", если перетянули за конец\n        gesture.dragging = \"end\";\n        return [end, nextValue];\n      }\n      return [nextValue, end];\n    }\n    if (dragging === \"end\") {\n      if (nextValue < start) {\n        // \"перехватиться\", если перетянули за начало\n        gesture.dragging = \"start\";\n        return [nextValue, start];\n      }\n      return [start, nextValue];\n    }\n\n    return value;\n  };\n\n  const snapDirection = (pos: number, target: EventTarget | null) => {\n    if (target === thumbStart.current) {\n      return \"start\";\n    }\n    if (target === thumbEnd.current) {\n      return \"end\";\n    }\n    return Math.abs((start ?? 0) - pos) <= Math.abs(end - pos)\n      ? \"start\"\n      : \"end\";\n  };\n\n  const onStart: TouchEventHandler = (e: TouchEvent) => {\n    const boundingRect = container.current?.getBoundingClientRect();\n    gesture.containerWidth = boundingRect?.width ?? 0;\n\n    const absolutePosition = e.startX - (boundingRect?.left ?? 0);\n    const pos = offsetToValue(absolutePosition);\n    gesture.dragging = snapDirection(pos, e.originalEvent.target);\n    gesture.startX = absolutePosition;\n\n    onChange?.(updateRange(pos), e);\n    e.originalEvent.stopPropagation();\n  };\n\n  const onMove: TouchEventHandler = (e: TouchEvent) => {\n    onChange?.(updateRange(offsetToValue(gesture.startX + (e.shiftX || 0))), e);\n\n    e.originalEvent.stopPropagation();\n    e.originalEvent.preventDefault();\n  };\n\n  const onEnd: TouchEventHandler = (e) => {\n    gesture.dragging = false;\n    e.originalEvent.stopPropagation();\n  };\n\n  const toPercent = (v: number) => ((v - min) / (max - min)) * 100;\n  const draggerStyle = isRange\n    ? {\n        width: `${toPercent(end) - toPercent(start ?? 0)}%`,\n        left: `${toPercent(start ?? 0)}%`,\n      }\n    : {\n        width: `${toPercent(end)}%`,\n      };\n\n  return (\n    <Touch\n      data-value={isRange ? value.join(\",\") : value}\n      {...restProps}\n      {...(disabled ? {} : { onStart, onMove, onEnd })}\n      vkuiClass={classNames(\n        getClassName(\"Slider\", platform),\n        `Slider--sizeY-${sizeY}`,\n        disabled && \"Slider--disabled\"\n      )}\n    >\n      <div ref={container} vkuiClass=\"Slider__in\">\n        <div vkuiClass=\"Slider__dragger\" style={draggerStyle}>\n          {isRange && (\n            <span\n              vkuiClass={classNames(\"Slider__thumb\", \"Slider__thumb--start\")}\n              ref={thumbStart}\n            />\n          )}\n          <span\n            vkuiClass={classNames(\"Slider__thumb\", \"Slider__thumb--end\")}\n            ref={thumbEnd}\n          />\n        </div>\n      </div>\n    </Touch>\n  );\n};\n\nexport const UniversalSlider = withAdaptivity(UniversalSliderDumb, {\n  sizeY: true,\n});\n"]},"metadata":{},"sourceType":"module"}