{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"children\", \"getScrollToLeft\", \"getScrollToRight\", \"showArrows\", \"scrollAnimationDuration\", \"hasMouse\", \"getRef\"];\nimport { createScopedElement } from \"../../lib/jsxRuntime\";\nimport * as React from \"react\";\nimport { withAdaptivity } from \"../../hoc/withAdaptivity\";\nimport HorizontalScrollArrow from \"./HorizontalScrollArrow\";\nimport { easeInOutSine } from \"../../lib/fx\";\nimport { useEventListener } from \"../../hooks/useEventListener\";\nimport { useExternRef } from \"../../hooks/useExternRef\";\nimport { classNames } from \"../../lib/classNames\";\n/**\n * timing method\n */\n\nfunction now() {\n  return performance && performance.now ? performance.now() : Date.now();\n}\n/**\n * Код анимации скрола, на основе полифила: https://github.com/iamdustan/smoothscroll\n * Константа взята из полифила (468), на дизайн-ревью уточнили до 250\n * @var {number} SCROLL_ONE_FRAME_TIME время анимации скролла\n */\n\n\nvar SCROLL_ONE_FRAME_TIME = 250;\n\nfunction doScroll(_ref) {\n  var scrollElement = _ref.scrollElement,\n      getScrollPosition = _ref.getScrollPosition,\n      animationQueue = _ref.animationQueue,\n      onScrollToRightBorder = _ref.onScrollToRightBorder,\n      onScrollEnd = _ref.onScrollEnd,\n      onScrollStart = _ref.onScrollStart,\n      initialScrollWidth = _ref.initialScrollWidth,\n      _ref$scrollAnimationD = _ref.scrollAnimationDuration,\n      scrollAnimationDuration = _ref$scrollAnimationD === void 0 ? SCROLL_ONE_FRAME_TIME : _ref$scrollAnimationD;\n\n  if (!scrollElement || !getScrollPosition) {\n    return;\n  }\n  /**\n   * максимальное значение сдвига влево\n   */\n\n\n  var maxLeft = initialScrollWidth - scrollElement.offsetWidth;\n  var startLeft = scrollElement.scrollLeft;\n  var endLeft = getScrollPosition(startLeft);\n  onScrollStart();\n\n  if (endLeft >= maxLeft) {\n    onScrollToRightBorder();\n    endLeft = maxLeft;\n  }\n\n  var startTime = now();\n\n  (function scroll() {\n    if (!scrollElement) {\n      onScrollEnd();\n      return;\n    }\n\n    var time = now();\n    var elapsed = Math.min((time - startTime) / scrollAnimationDuration, 1);\n    var value = easeInOutSine(elapsed);\n    var currentLeft = startLeft + (endLeft - startLeft) * value;\n    scrollElement.scrollLeft = Math.ceil(currentLeft);\n\n    if (scrollElement.scrollLeft !== Math.max(0, endLeft)) {\n      requestAnimationFrame(scroll);\n      return;\n    }\n\n    onScrollEnd();\n    animationQueue.shift();\n\n    if (animationQueue.length > 0) {\n      animationQueue[0]();\n    }\n  })();\n}\n\nvar HorizontalScroll = function HorizontalScroll(_ref2) {\n  var children = _ref2.children,\n      getScrollToLeft = _ref2.getScrollToLeft,\n      getScrollToRight = _ref2.getScrollToRight,\n      _ref2$showArrows = _ref2.showArrows,\n      showArrows = _ref2$showArrows === void 0 ? true : _ref2$showArrows,\n      _ref2$scrollAnimation = _ref2.scrollAnimationDuration,\n      scrollAnimationDuration = _ref2$scrollAnimation === void 0 ? SCROLL_ONE_FRAME_TIME : _ref2$scrollAnimation,\n      hasMouse = _ref2.hasMouse,\n      getRef = _ref2.getRef,\n      restProps = _objectWithoutProperties(_ref2, _excluded);\n\n  var _React$useState = React.useState(false),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      canScrollLeft = _React$useState2[0],\n      setCanScrollLeft = _React$useState2[1];\n\n  var _React$useState3 = React.useState(false),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      canScrollRight = _React$useState4[0],\n      setCanScrollRight = _React$useState4[1];\n\n  var isCustomScrollingRef = React.useRef(false);\n  var scrollerRef = useExternRef(getRef);\n  var animationQueue = React.useRef([]);\n\n  function scrollTo(getScrollPosition) {\n    var scrollElement = scrollerRef.current;\n    animationQueue.current.push(function () {\n      var _scrollElement$firstE;\n\n      return doScroll({\n        scrollElement: scrollElement,\n        getScrollPosition: getScrollPosition,\n        animationQueue: animationQueue.current,\n        onScrollToRightBorder: function onScrollToRightBorder() {\n          return setCanScrollRight(false);\n        },\n        onScrollEnd: function onScrollEnd() {\n          return isCustomScrollingRef.current = false;\n        },\n        onScrollStart: function onScrollStart() {\n          return isCustomScrollingRef.current = true;\n        },\n        initialScrollWidth: (scrollElement === null || scrollElement === void 0 ? void 0 : (_scrollElement$firstE = scrollElement.firstElementChild) === null || _scrollElement$firstE === void 0 ? void 0 : _scrollElement$firstE.scrollWidth) || 0,\n        scrollAnimationDuration: scrollAnimationDuration\n      });\n    });\n\n    if (animationQueue.current.length === 1) {\n      animationQueue.current[0]();\n    }\n  }\n\n  var onscroll = React.useCallback(function () {\n    if (showArrows && hasMouse && scrollerRef.current && !isCustomScrollingRef.current) {\n      var scrollElement = scrollerRef.current;\n      setCanScrollLeft(scrollElement.scrollLeft > 0);\n      setCanScrollRight(scrollElement.scrollLeft + scrollElement.offsetWidth < scrollElement.scrollWidth);\n    }\n  }, [hasMouse, scrollerRef, showArrows]);\n  var scrollEvent = useEventListener(\"scroll\", onscroll);\n  React.useEffect(function () {\n    if (scrollerRef.current) {\n      scrollEvent.add(scrollerRef.current);\n    }\n  }, [scrollEvent, scrollerRef]);\n  React.useEffect(onscroll, [scrollerRef, children, onscroll]);\n  return createScopedElement(\"div\", _extends({}, restProps, {\n    vkuiClass: classNames(\"HorizontalScroll\", _defineProperty({}, \"HorizontalScroll--withConstArrows\", showArrows === \"always\"))\n  }), showArrows && hasMouse && canScrollLeft && createScopedElement(HorizontalScrollArrow, {\n    direction: \"left\",\n    onClick: function onClick() {\n      if (getScrollToLeft) {\n        scrollTo(getScrollToLeft);\n      }\n    }\n  }), showArrows && hasMouse && canScrollRight && createScopedElement(HorizontalScrollArrow, {\n    direction: \"right\",\n    onClick: function onClick() {\n      if (getScrollToRight) {\n        scrollTo(getScrollToRight);\n      }\n    }\n  }), createScopedElement(\"div\", {\n    vkuiClass: \"HorizontalScroll__in\",\n    ref: scrollerRef\n  }, createScopedElement(\"div\", {\n    vkuiClass: \"HorizontalScroll__in-wrapper\"\n  }, children)));\n}; // eslint-disable-next-line import/no-default-export\n\n\nexport default withAdaptivity(HorizontalScroll, {\n  hasMouse: true\n});","map":{"version":3,"mappings":"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","names":["React","withAdaptivity","HorizontalScrollArrow","easeInOutSine","useEventListener","useExternRef","classNames","now","performance","Date","SCROLL_ONE_FRAME_TIME","doScroll","scrollElement","getScrollPosition","animationQueue","onScrollToRightBorder","onScrollEnd","onScrollStart","initialScrollWidth","scrollAnimationDuration","maxLeft","offsetWidth","startLeft","scrollLeft","endLeft","startTime","scroll","time","elapsed","Math","min","value","currentLeft","ceil","max","requestAnimationFrame","shift","length","HorizontalScroll","children","getScrollToLeft","getScrollToRight","showArrows","hasMouse","getRef","restProps","useState","canScrollLeft","setCanScrollLeft","canScrollRight","setCanScrollRight","isCustomScrollingRef","useRef","scrollerRef","scrollTo","current","push","firstElementChild","scrollWidth","onscroll","useCallback","scrollEvent","useEffect","add","createScopedElement","vkuiClass","direction","onClick","ref"],"sources":["/Users/al.balandin/code/vkvideo-test/node_modules/@vkontakte/vkui/src/components/HorizontalScroll/HorizontalScroll.tsx"],"sourcesContent":["import * as React from \"react\";\nimport { withAdaptivity, AdaptivityProps } from \"../../hoc/withAdaptivity\";\nimport HorizontalScrollArrow from \"./HorizontalScrollArrow\";\nimport { easeInOutSine } from \"../../lib/fx\";\nimport { useEventListener } from \"../../hooks/useEventListener\";\nimport { useExternRef } from \"../../hooks/useExternRef\";\nimport { HasRef } from \"../../types\";\nimport { classNames } from \"../../lib/classNames\";\nimport \"./HorizontalScroll.css\";\n\ninterface ScrollContext {\n  scrollElement: HTMLElement | null;\n  scrollAnimationDuration: number;\n  animationQueue: VoidFunction[];\n  getScrollPosition: (currentPosition: number) => number;\n  onScrollToRightBorder: VoidFunction;\n  onScrollEnd: VoidFunction;\n  onScrollStart: VoidFunction;\n  /**\n   * Начальная ширина прокрутки.\n   * В некоторых случаях может отличаться от текущей ширины прокрутки из-за transforms: translate\n   */\n  initialScrollWidth: number;\n}\n\nexport type ScrollPositionHandler = (currentPosition: number) => number;\n\nexport interface HorizontalScrollProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    AdaptivityProps,\n    HasRef<HTMLDivElement> {\n  /**\n   * Функция для расчета величины прокрутки при клике на левую стрелку.\n   */\n  getScrollToLeft?: ScrollPositionHandler;\n  /**\n   * Функция для расчета величины прокрутки при клике на правую стрелку.\n   */\n  getScrollToRight?: ScrollPositionHandler;\n  showArrows?: boolean | \"always\";\n  scrollAnimationDuration?: number;\n}\n\n/**\n * timing method\n */\nfunction now() {\n  return performance && performance.now ? performance.now() : Date.now();\n}\n\n/**\n * Код анимации скрола, на основе полифила: https://github.com/iamdustan/smoothscroll\n * Константа взята из полифила (468), на дизайн-ревью уточнили до 250\n * @var {number} SCROLL_ONE_FRAME_TIME время анимации скролла\n */\nconst SCROLL_ONE_FRAME_TIME = 250;\n\nfunction doScroll({\n  scrollElement,\n  getScrollPosition,\n  animationQueue,\n  onScrollToRightBorder,\n  onScrollEnd,\n  onScrollStart,\n  initialScrollWidth,\n  scrollAnimationDuration = SCROLL_ONE_FRAME_TIME,\n}: ScrollContext) {\n  if (!scrollElement || !getScrollPosition) {\n    return;\n  }\n\n  /**\n   * максимальное значение сдвига влево\n   */\n  const maxLeft = initialScrollWidth - scrollElement.offsetWidth;\n\n  let startLeft = scrollElement.scrollLeft;\n  let endLeft = getScrollPosition(startLeft);\n\n  onScrollStart();\n\n  if (endLeft >= maxLeft) {\n    onScrollToRightBorder();\n    endLeft = maxLeft;\n  }\n\n  const startTime = now();\n\n  (function scroll() {\n    if (!scrollElement) {\n      onScrollEnd();\n      return;\n    }\n\n    const time = now();\n    const elapsed = Math.min((time - startTime) / scrollAnimationDuration, 1);\n\n    const value = easeInOutSine(elapsed);\n\n    const currentLeft = startLeft + (endLeft - startLeft) * value;\n    scrollElement.scrollLeft = Math.ceil(currentLeft);\n\n    if (scrollElement.scrollLeft !== Math.max(0, endLeft)) {\n      requestAnimationFrame(scroll);\n      return;\n    }\n\n    onScrollEnd();\n    animationQueue.shift();\n    if (animationQueue.length > 0) {\n      animationQueue[0]();\n    }\n  })();\n}\n\nconst HorizontalScroll: React.FC<HorizontalScrollProps> = ({\n  children,\n  getScrollToLeft,\n  getScrollToRight,\n  showArrows = true,\n  scrollAnimationDuration = SCROLL_ONE_FRAME_TIME,\n  hasMouse,\n  getRef,\n  ...restProps\n}: HorizontalScrollProps) => {\n  const [canScrollLeft, setCanScrollLeft] = React.useState(false);\n  const [canScrollRight, setCanScrollRight] = React.useState(false);\n\n  const isCustomScrollingRef = React.useRef(false);\n\n  const scrollerRef = useExternRef(getRef);\n\n  const animationQueue = React.useRef<VoidFunction[]>([]);\n\n  function scrollTo(getScrollPosition: (offset: number) => number) {\n    const scrollElement = scrollerRef.current;\n\n    animationQueue.current.push(() =>\n      doScroll({\n        scrollElement,\n        getScrollPosition,\n        animationQueue: animationQueue.current,\n        onScrollToRightBorder: () => setCanScrollRight(false),\n        onScrollEnd: () => (isCustomScrollingRef.current = false),\n        onScrollStart: () => (isCustomScrollingRef.current = true),\n        initialScrollWidth: scrollElement?.firstElementChild?.scrollWidth || 0,\n        scrollAnimationDuration,\n      })\n    );\n    if (animationQueue.current.length === 1) {\n      animationQueue.current[0]();\n    }\n  }\n\n  const onscroll = React.useCallback(() => {\n    if (\n      showArrows &&\n      hasMouse &&\n      scrollerRef.current &&\n      !isCustomScrollingRef.current\n    ) {\n      const scrollElement = scrollerRef.current;\n\n      setCanScrollLeft(scrollElement.scrollLeft > 0);\n      setCanScrollRight(\n        scrollElement.scrollLeft + scrollElement.offsetWidth <\n          scrollElement.scrollWidth\n      );\n    }\n  }, [hasMouse, scrollerRef, showArrows]);\n\n  const scrollEvent = useEventListener(\"scroll\", onscroll);\n  React.useEffect(() => {\n    if (scrollerRef.current) {\n      scrollEvent.add(scrollerRef.current);\n    }\n  }, [scrollEvent, scrollerRef]);\n  React.useEffect(onscroll, [scrollerRef, children, onscroll]);\n\n  return (\n    <div\n      {...restProps}\n      vkuiClass={classNames(\"HorizontalScroll\", {\n        [\"HorizontalScroll--withConstArrows\"]: showArrows === \"always\",\n      })}\n    >\n      {showArrows && hasMouse && canScrollLeft && (\n        <HorizontalScrollArrow\n          direction=\"left\"\n          onClick={() => {\n            if (getScrollToLeft) {\n              scrollTo(getScrollToLeft);\n            }\n          }}\n        />\n      )}\n      {showArrows && hasMouse && canScrollRight && (\n        <HorizontalScrollArrow\n          direction=\"right\"\n          onClick={() => {\n            if (getScrollToRight) {\n              scrollTo(getScrollToRight);\n            }\n          }}\n        />\n      )}\n      <div vkuiClass=\"HorizontalScroll__in\" ref={scrollerRef}>\n        <div vkuiClass=\"HorizontalScroll__in-wrapper\">{children}</div>\n      </div>\n    </div>\n  );\n};\n\n// eslint-disable-next-line import/no-default-export\nexport default withAdaptivity(HorizontalScroll, {\n  hasMouse: true,\n});\n"]},"metadata":{},"sourceType":"module"}