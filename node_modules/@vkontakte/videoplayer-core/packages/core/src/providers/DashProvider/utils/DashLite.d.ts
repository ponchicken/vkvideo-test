import { Milliseconds } from '@vkontakte/videoplayer-shared';
import HttpVideoBuffer from "../../../utils/buffer/HttpVideoBuffer";
import { IDashConfig, IRef, IRepresentation } from '../types';
interface IParams {
    video: HTMLVideoElement;
    buffer: HttpVideoBuffer;
    selectRepresentation: (representations: IRepresentation[]) => IRepresentation;
    onManifestReady: (representations: IRepresentation[]) => void;
    onIdxRequestPing: (ping: Milliseconds) => void;
    onResponseHeaders: (headers: Headers) => void;
    onBandwidthChange: (payload: {
        size: number;
        duration: number;
        speed: number;
    }) => void;
    onRepresentationPlay: (representation: IRepresentation) => void;
    onError: (id: string, message: string, thrown?: Error | unknown) => void;
    config: IDashConfig;
    onDashCallback?: (eventName: string, param?: any) => any;
}
export default class DashLite {
    private _params;
    private _representations;
    private _appendVector;
    private _currentRepresentation?;
    private _stream;
    private _lastLoadOffset?;
    private _loopTimeout?;
    private _cachingPaused;
    private _duration;
    private STREAM_END_THRESHOLD;
    private _video;
    private _buffer;
    private _onDashCallback;
    private _config;
    constructor(params: IParams);
    /**
     * Parse duration from ISO8601 string.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
     * @see https://github.com/moment/moment/blob/develop/src/lib/duration/create.js#L13
     */
    _parseDurationFromISO8601(input: string): number;
    getRepresentations(): IRepresentation[];
    attachSource(manifestUrl: string, failoverHosts?: string[]): void;
    attachManifest(manifestString: string, failoverHosts?: string[], origin?: string): void;
    _loadInitAndSidx(representation: IRepresentation, cb?: () => void): void;
    startPlay(representation: IRepresentation): void;
    _loadRef(representation: IRepresentation, fromTime: number, needToSeek?: boolean, forcePrecise?: boolean): void;
    setQualityByRepresentation(newRepresentation: IRepresentation, force?: boolean): void;
    setQuality(index: number): void;
    pauseCaching(): void;
    resumeCaching(): void;
    seek(time: number, forcePrecise?: boolean): void;
    updateRefsForCurrentTime(): void;
    _findRef(time: number): IRef | undefined;
    _isLastRef(ref: IRef): boolean;
    _findBufferRangeEnd(time: number): number;
    destroy(): void;
}
export {};
