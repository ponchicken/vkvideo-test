export declare function getTimeMilliseconds(): number;
export declare function elapsedSince(ts: number): number;
/**
 * url resolver function
 * constructs full path if URL is relative to manifest
 * optionally adds random url parameter to bypass browser cache
 */
export declare function urlResolver(homeUrl: string): {
    resolve: (url: string, nocache: boolean, lowLatency?: boolean) => string;
};
/**
 * event listener helper - listen just once, then remove listener
 */
export declare function listenOnce(element: HTMLElement, eventName: string, listener: (...args: any[]) => void): void;
interface IRequestDataResult {
    withBitrateReporting: IWithBitrateReporting;
    withParallel: IWithParallel;
    withJSONResponse: IWithJSONResponse;
    withRetryCount: IWithRetryCount;
    withRetryInterval: IWithRetryInterval;
    withTimeout: IWithTimeout;
    withFinally: IWithFinally;
    send: ISend;
    abort: () => void;
}
declare type IWithBitrateReporting = IBuilderMethod<[listener: any]>;
declare type IWithParallel = IBuilderMethod<[parallel: any]>;
declare type IWithJSONResponse = IBuilderMethod<[]>;
declare type IWithRetryCount = IBuilderMethod<[count: number]>;
declare type IWithRetryInterval = IBuilderMethod<[
    interval: number | undefined,
    maxInterval: number | undefined
]>;
declare type IWithTimeout = IBuilderMethod<[timeoutMs: number]>;
declare type IWithFinally = IBuilderMethod<[final: () => void]>;
declare type ISend = IBuilderMethod<[]>;
declare type IBuilderMethod<TParams extends any[]> = (...params: TParams) => IRequestDataResult;
/**
 * fetch data helper with retry and timeout handler
 */
export declare function requestData(url: string, cb: (response: any) => void, errorCB: () => void, retryCB: () => void): IRequestDataResult;
export {};
