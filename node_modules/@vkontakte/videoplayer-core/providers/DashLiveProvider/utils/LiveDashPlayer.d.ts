import { Milliseconds } from '@vkontakte/videoplayer-shared';
import { IRepresentation } from '../types';
interface IParams {
    videoElement: HTMLVideoElement;
    playerCallback: (...args: any) => void;
    config: {
        minBuffer: Milliseconds;
        lowLatencyMinBuffer: Milliseconds;
        minBufferSegments: number;
        lowLatencyMinBufferSegments: number;
        maxParallelRequests: number;
    };
    logger: (...args: any[]) => void;
}
export default class LiveDashPlayer {
    private paused;
    private autoQuality;
    private maxAutoQuality;
    private buffering;
    private destroyed;
    private videoPlayStarted;
    private lowLatency;
    private rep?;
    private bitrate;
    private manifest;
    private bitrateSwitcher?;
    private filesFetcher?;
    private sourceBuffer?;
    private mediaSource?;
    private currentManifestEntry?;
    private manifestRequest?;
    private manifestRefetchTimer?;
    private bufferStates;
    private downloadRate?;
    private sourceJitter;
    private chunkRateEstimator;
    private manifestUrl;
    private urlResolver;
    private params;
    constructor(params: IParams);
    attachSource(manifestUrl: string): void;
    /**
     * switch to auto quality
     */
    setAutoQualityEnabled(enabled: boolean): void;
    setMaxAutoQuality(height: number | undefined): void;
    /**
     * switch quality by name
     */
    switchByName(name: string): void;
    /**
     * seek to actual video position
     */
    catchUp(): void;
    stop(): void;
    pause(): void;
    play(onPlayNotAllowed?: () => void): void;
    startPlay(targetQ: IRepresentation, autoQuality: boolean): void;
    /**
     * destroy player
     */
    destroy(): void;
    reinit(newManifestUrl: string): void;
    /**
     * if all retries fail...
     */
    private _handleNetworkError;
    /**
     * Retry request
     */
    private _retryCallback;
    /**
     * how many seconds are there in the buffer
     */
    private _getBufferSizeSec;
    /**
     * send buffering notification to player
     */
    private _notifyBuffering;
    /**
     * initialize video tag, add necessary event listeners
     * @private
     */
    private _initVideo;
    /**
     * there may be small gaps of several milliseconds when switching quality
     * we jump over these gaps here
     */
    private _fixupStall;
    /**
     * return best quality for rate
     */
    private _selectQuality;
    private shouldPlay;
    /**
     * set video source
     */
    private _setVideoSrc;
    /**
     * initialize player with target quality
     */
    private _initPlayerWith;
    /**
     * represents specific quality stream
     */
    private _representation;
    /**
     * switch to quality
     * TODO: Если новое качество выше старого – переключиться сразу. Если хуже, доиграть буфер
     */
    private _switchToQuality;
    /**
     * check if quality is available
     */
    private _qualityAvailable;
    /**
     * analyze bitrate data and switch qualities accordingly
     */
    private _initBitrateSwitcher;
    /**
     * load and parse manifest file
     */
    private _fetchManifest;
    private _playVideoElement;
    /**
     * update internal state when manifest was received from remote
     */
    private _handleManifestUpdate;
    /**
     * schedule manifest update after delay
     */
    private _refetchManifest;
    private _initManifest;
}
export {};
