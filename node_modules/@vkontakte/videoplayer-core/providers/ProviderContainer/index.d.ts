import { IMetadata, ISources, IVideoTrack, IVolumeState, VideoFormat } from "../../player/types";
import { ITuningConfig } from "../../utils/tuningConfig";
import { IError, ISubject, IValueSubject, Subject, ValueSubject, IRange } from '@vkontakte/videoplayer-shared';
import { IDesiredState, IProviderDependencies } from '../types';
import { IProviderContainer, IProviderEntry } from './types';
interface IParams extends IProviderDependencies {
    container: HTMLElement;
    sources: ISources;
    meta: IMetadata;
    screenFormatsPriority: VideoFormat[];
    chromecastFormatsPriority: VideoFormat[];
    desiredState: IDesiredState;
    tuning: ITuningConfig;
}
export default class ProviderContainer implements IProviderContainer {
    current$: IValueSubject<IProviderEntry>;
    providerError$: ISubject<IError>;
    noAvailableProvidersError$: ISubject<void>;
    providerOutput: {
        position$: ValueSubject<number>;
        duration$: ValueSubject<number>;
        volume$: ValueSubject<IVolumeState>;
        currentVideoTrack$: ValueSubject<IVideoTrack | undefined>;
        availableVideoTracks$: ValueSubject<IVideoTrack[]>;
        autoVideoTrackLimitingAvailable$: ValueSubject<boolean>;
        currentBuffer$: ValueSubject<IRange<number> | undefined>;
        isBuffering$: ValueSubject<boolean>;
        error$: Subject<IError>;
        willSeekEvent$: Subject<void>;
        seekedEvent$: Subject<void>;
        loopedEvent$: Subject<number>;
        endedEvent$: Subject<void>;
        firstBytesEvent$: Subject<void>;
        firstFrameEvent$: Subject<void>;
        canplay$: Subject<void>;
        isLive$: ValueSubject<undefined>;
        liveTime$: ValueSubject<undefined>;
        availableTextTracks$: ValueSubject<never[]>;
        currentTextTrack$: ValueSubject<undefined>;
        hostname$: ValueSubject<undefined>;
        httpConnectionType$: ValueSubject<undefined>;
        httpConnectionReused$: ValueSubject<undefined>;
        element$: ValueSubject<HTMLVideoElement | undefined>;
    };
    private subscription;
    private screenFormatsIterator;
    private chromecastFormatsIterator;
    private log;
    private params;
    constructor(params: IParams);
    init(): void;
    destroy(): void;
    private initProvider;
    private reinitProvider;
    private switchToNextProvider;
    private destroyProvider;
    private createProvider;
    private createScreenProvider;
    private createChromecastProvider;
    private chooseDestination;
    private chooseFormat;
    private skipFormat;
    private handleNoFormatsError;
    private initProviderErrorHandling;
}
export {};
