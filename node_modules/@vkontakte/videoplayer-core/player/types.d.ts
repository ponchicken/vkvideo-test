import { IObservable, IValueObservable, IValueSubject, ILogEntry, Kbps, Milliseconds, Seconds, IRectangle, IError } from '@vkontakte/videoplayer-shared';
import { QualityLimits, VideoQuality } from "../utils/quality/types";
export interface StartEnd<Unit extends number> {
    start: Unit;
    end: Unit;
}
export interface IPlayer {
    info: IPlayerInfo;
    events: IPlayerEvents;
    /**
     * Инициализация видео
     */
    initVideo(config: IConfig): IPlayer;
    /**
     *  Полная деинициализация плеера
     */
    destroy(): void;
    play(): IPlayer;
    pause(): IPlayer;
    stop(): IPlayer;
    /**
     * @param time
     * @param forcePrecise Для длинных видео перемотка по-умолчанию может быть не точной (т.к. точная выполняется долго). С этим флагом перемотка будет гарантировано точной (но возможно медленной)
     */
    seekTime(time: Seconds, forcePrecise?: boolean): IPlayer;
    /**
     * @param percent: number [0; 1]
     */
    seekPercent(percent: number): IPlayer;
    /**
     * @param percent: number [0; 1]
     */
    setVolume(percent: number): IPlayer;
    setMuted(muted: boolean): IPlayer;
    setQuality(quality: VideoQuality): IPlayer;
    setAutoQuality(enable: boolean): IPlayer;
    setAutoQualityLimits(limit: QualityLimits): IPlayer;
    setPlaybackRate(playbackRate: PlaybackRate): IPlayer;
    setLooped(isLooped: boolean): IPlayer;
    setExternalTextTracks(tracks: Omit<IExternalTextTrack, 'type'>[]): IPlayer;
    selectTextTrack(id: ITextTrack['id'] | undefined): IPlayer;
    setTextTrackCueSettings(settings: ICueSettings): IPlayer;
    /**
     * Включает или отключает Chromecast
     */
    toggleChromecast(): void;
    /**
     * Возвращает наиболее точное время воспроизведения.
     * Может быть точнее, чем `info.position$` в промежутках между timeupdate
     */
    getExactTime(): number;
    /**
     * Возвращает все логи с момента инициализации плеера
     */
    getAllLogs(): ILogEntry[];
    experimental: {
        /**
         * Элемент, который сейчас вставлен в container.
         * Может быть видеоэлементом, iframe и вообще чем угодно в общем случае.
         */
        element$: IValueObservable<HTMLElement | undefined>;
        enableDebugTelemetry$: IValueSubject<boolean>;
        dumpTelemetry: (receiver: (value: Record<string, any>) => void) => void;
    };
}
/**
 * События плеера.
 * События, начинающиеся с `will...` случаются в начале совершения действия,
 * остальные - в момент окончания действия.
 */
export interface IPlayerEvents {
    /**
     * Плеер получил ссылку и готов к взаимодействию
     */
    inited$: IObservable<void>;
    /**
     * Видео начало воспроизведение в первый раз
     * Соответствует первому для видео внешнему запуску воспроизведения
     * Параметр содержит значение isMuted (true если видео заиграло без звука, false если со звуком)
     */
    started$: IObservable<boolean>;
    /**
     * Попытка начать играть видео
     */
    startAttempt$: IObservable<StartStatus>;
    /**
     * Запрошена пауза
     */
    willPause$: IObservable<void>;
    /**
     * Запрошено возобновление воспроизведения после паузы
     */
    willResume$: IObservable<void>;
    /**
     * Плеер будет уничтожен, в момент события можно синхронно запросить последние данные о его состоянии.
     */
    willDestruct$: IObservable<void>;
    /**
     * Просмотрен промежуток видео.
     * Параметр содержит диапазон: начальная и конечная позиция просмотра (в секундах от начала ролика).
     */
    watchCoverageRecord$: IObservable<StartEnd<Seconds>>;
    /**
     * Просмотрен промежуток видео. Промежуток видео, которые были просмотрены пользователем.
     * Параметр содержит диапазон: начальный и конечный UTC tipestamp?
     */
    watchCoverageLive$: IObservable<StartEnd<Milliseconds>>;
    /**
     * Ошибка в работе после которой воспроизведение было восстановлено
     */
    managedError$: IObservable<IError>;
    /**
     * Критическая ошибка, воспроизведение более не возможно
     */
    fatalError$: IObservable<IError>;
    /**
     * Проигрывание видео завершено
     */
    ended$: IObservable<void>;
    /**
     * Видео доиграло до конца, перемоталось в начало и заиграло снова, в параметре время в которое произошло переключение
     */
    looped$: IObservable<Seconds>;
    /**
     * Совершена перемотка
     */
    seeked$: IObservable<void>;
    /**
     * Запрошена перемотка
     */
    willSeek$: IObservable<ISeekRequest>;
    /**
     * Получен первый кусок контента от сервера раздачи видео
     * Событие поддерживается не во всех провайдерах (т.к. не все способы проигрывания видео поддерживают такой интерфейс)
     *
     * Содержит время в миллисекундах: сколько прошло с момента инициализации
     */
    firstBytes$: IObservable<Milliseconds>;
    /**
     * Показан первый кадр
     *
     * Содержит время в миллисекундах: сколько прошло времени с инициализации
     */
    firstFrame$: IObservable<Milliseconds>;
    /**
     * Плеер готов начать воспроизведение
     *
     * Содержит время в миллисекундах: сколько прошло времени с инициализации
     */
    canplay$: IObservable<Milliseconds>;
    /**
     * Логи для отладки
     */
    log$: IObservable<ILogEntry>;
}
export interface IPlayerInfo {
    playbackState$: IValueObservable<PlaybackState>;
    /**
     * Текущая позиция.
     * В секундах.
     *
     * default value: `0`
     */
    position$: IValueObservable<number>;
    /**
     * Длительность видео.
     * В секундах.
     *
     * default value: `Infinity`
     */
    duration$: IValueObservable<number>;
    /**
     * default value: `false`
     */
    muted$: IValueObservable<boolean>;
    /**
     * default value: `1`
     */
    volume$: IValueObservable<number>;
    /**
     * Список доступных качеств. Отсортированы по возрастанию.
     *
     * default value: `[]`
     */
    availableQualities$: IValueObservable<VideoQuality[]>;
    /**
     * Список фпс для доступных качеств
     *
     * default value: `{}`
     */
    availableQualitiesFps$: IValueObservable<FpsByQuality>;
    /**
     * Реальное качество, в котором сейчас воспроизводится видео.
     *
     * default value: `undefined`
     */
    currentQuality$: IValueObservable<VideoQuality | undefined>;
    /**
     * Будет ли плеер адаптивно переключать качество в зависимости от канала пользователя
     */
    isAutoQualityEnabled$: IValueObservable<boolean>;
    /**
     * Доступна ли установка лимитов авто качества
     */
    autoQualityLimitingAvailable$: IValueObservable<boolean>;
    /**
     * Текущие лимиты авто-качества
     */
    autoQualityLimits$: IValueObservable<QualityLimits>;
    /**
     * Текущая скорость воспроизведения
     */
    currentPlaybackRate$: IValueObservable<PlaybackRate>;
    /**
     * Текущий буффер (тот, который содержит текущую позицию воспроизведения)
     *
     * default value: `undefined`
     */
    currentBuffer$: IValueObservable<StartEnd<Seconds> | undefined>;
    /**
     * Статус буферизации видео. true если буфер пустой и воспроизведение прервано
     * В отличии от isStalled показывает и буферизации на старте и после перемотки
     */
    isBuffering$: IValueObservable<boolean>;
    /**
     * Статус только нежелательной буферизации, возникает при опустошении буфера в процессе воспроизведения
     * и не возникает при начальном наполнении буфера или после перемотки
     */
    isStalled$: IValueObservable<boolean>;
    /**
     * Закончилось ли видео
     */
    isEnded$: IValueObservable<boolean>;
    /**
     * Зациклено ли видео
     */
    isLooped$: IValueObservable<boolean>;
    /**
     * Бесконечный ли стрим
     */
    isLive$: IValueObservable<boolean | undefined>;
    /**
     * Серверное время текущего кадра
     */
    liveTime$: IValueObservable<Milliseconds | undefined>;
    /**
     * Формат, в котором сейчас воспроизводится видео
     */
    currentFormat$: IValueObservable<VideoFormat | undefined>;
    /**
     * Список всех доступных субтитров
     */
    availableTextTracks$: IValueObservable<ITextTrack[]>;
    /**
     * Выбранная и отображаемая дорожка субтитров
     */
    currentTextTrack$: IValueObservable<ITextTrack['id'] | undefined>;
    /**
     * Рассчитанная ширина канала пользователя
     */
    throughputEstimation$: IValueObservable<Kbps | undefined>;
    /**
     * Round-Trip-Time, время от отправки запроса до получения ответа. Весьма неточное.
     */
    rttEstimation$: IValueObservable<Milliseconds | undefined>;
    /**
     * Битрейт текущей видео-дорожки
     */
    videoBitrate$: IValueObservable<Kbps | undefined>;
    /**
     * Хост с которого воспроизводится видео
     */
    hostname$: IValueObservable<string | undefined>;
    /**
     * Тип HTTP соединения последнего запроса
     */
    httpConnectionType$: IValueObservable<HttpConnectionType | undefined>;
    /**
     * Было ли переиспользовано последнее HTTP соединение
     */
    httpConnectionReused$: IValueObservable<boolean | undefined>;
    /**
     * Состояние подключения Chromecast
     */
    chromecastState$: IValueObservable<ChromecastState>;
    /**
     * Имя устройства, куда выводится видео через Chromecast.
     * `undefined`, если видео не играет на Chromecast устройстве
     */
    chromecastDeviceName$: IValueObservable<string | undefined>;
    /**
     * Фактический размер видео
     */
    intrinsicVideoSize$: IValueObservable<{
        width: number;
        height: number;
    } | undefined>;
}
export declare enum PlaybackState {
    STOPPED = "stopped",
    PLAYING = "playing",
    PAUSED = "paused"
}
export interface IVolumeState {
    /**
     * range: [0;1]
     */
    volume: number;
    muted: boolean;
}
export interface IConfig {
    container: string | HTMLElement;
    sources: ISources;
    meta?: IMetadata;
}
export interface ISources {
    [VideoFormat.MPEG]?: IMpegSource;
    [VideoFormat.DASH]?: IDashSource;
    [VideoFormat.DASH_SEP]?: IDashURLSource;
    [VideoFormat.DASH_WEBM]?: IDashURLSource;
    [VideoFormat.DASH_ONDEMAND]?: IDashURLSource;
    [VideoFormat.DASH_LIVE]?: IDashURLSource;
    [VideoFormat.DASH_LIVE_WEBM]?: IDashURLSource;
    [VideoFormat.HLS]?: IHLSSource;
    [VideoFormat.HLS_ONDEMAND]?: IHLSSource;
    [VideoFormat.HLS_LIVE]?: IHLSLiveSource;
    [VideoFormat.WEB_RTC_LIVE]?: URLSource;
}
export interface IMetadata {
    title?: string;
    subtitle?: string;
    videoId?: string;
}
declare type QualitySetSource = Partial<Record<VideoQuality, string>>;
export declare type URLSource = {
    type: 'url';
    url: string;
};
export declare type RawSource = {
    type: 'raw';
    raw: string;
};
export declare type URLSourceWithSeek = URLSource & Partial<{
    maxSeekBackTime: Milliseconds;
}>;
export declare type IMpegSource = QualitySetSource;
export declare type IDashURLSource = URLSource;
export declare type IDashSource = URLSource | RawSource;
export declare type IHLSSource = URLSource;
export declare type IHLSLiveSource = URLSourceWithSeek;
export declare enum VideoFormat {
    MPEG = "MPEG",
    DASH = "DASH",
    DASH_SEP = "DASH_SEP",
    /** @deprecated Используйте DASH_SEP */
    DASH_SEP_VK = "DASH_SEP",
    DASH_WEBM = "DASH_WEBM",
    /** @deprecated Используйте DASH_WEBM */
    DASH_WEBM_VK = "DASH_WEBM",
    DASH_ONDEMAND = "DASH_ONDEMAND",
    /** @deprecated Используйте DASH_ONDEMAND */
    DASH_ONDEMAND_VK = "DASH_ONDEMAND",
    DASH_LIVE = "DASH_LIVE",
    /** @deprecated */
    DASH_LIVE_WEBM = "DASH_LIVE_WEBM",
    HLS = "HLS",
    HLS_ONDEMAND = "HLS_ONDEMAND",
    /** @deprecated Используйте HLS */
    HLS_JS = "HLS",
    HLS_LIVE = "HLS_LIVE",
    WEB_RTC_LIVE = "WEB_RTC_LIVE"
}
export interface IVideoTrack {
    id: string;
    quality: VideoQuality;
    bitrate?: Kbps;
    size?: IRectangle;
    fps?: number;
}
interface ITextTrackBase {
    type: 'external' | 'internal';
    id: string;
    language?: string;
    label?: string;
    url?: string;
}
export interface IExternalTextTrack extends ITextTrackBase {
    type: 'external';
    url: string;
}
interface IInternalTextTrack extends ITextTrackBase {
    type: 'internal';
}
export declare type ITextTrack = IExternalTextTrack | IInternalTextTrack;
export interface ICueSettings {
    align?: 'left' | 'center' | 'right';
    position?: number | 'auto';
    size?: number;
    line?: number | 'auto';
}
export declare enum VideoDestination {
    SCREEN = "SCREEN",
    CHROMECAST = "CHROMECAST"
}
export declare enum ChromecastState {
    NOT_AVAILABLE = "NOT_AVAILABLE",
    AVAILABLE = "AVAILABLE",
    CONNECTING = "CONNECTING",
    CONNECTED = "CONNECTED"
}
export interface ISeekRequest {
    from: Seconds;
    to: Seconds;
}
export declare enum StartStatus {
    SuccessWithSound = "success_with_sound",
    SuccessWithoutSound = "success_without_sound",
    Failed = "failed"
}
export declare enum HttpConnectionType {
    HTTP1 = "http1",
    HTTP2 = "http2",
    QUIC = "quic"
}
export declare enum SeekOperationState {
    None = "none",
    Requested = "requested",
    Applying = "applying"
}
declare type SeekStateNone = {
    state: SeekOperationState.None;
};
declare type SeekStateNotNone = {
    state: Exclude<SeekOperationState, SeekOperationState.None>;
    position: Milliseconds;
    forcePrecise: boolean;
};
export declare type SeekState = SeekStateNone | SeekStateNotNone;
export declare type FpsByQuality = Partial<Record<VideoQuality, number>>;
export declare type PlaybackRate = number;
export {};
