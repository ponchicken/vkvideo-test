import { HttpConnectionType, ICueSettings, StartEnd, PlaybackRate } from "./types";
import { QualityLimits, VideoQuality } from "../utils/quality/types";
import { IOptionalTuningConfig } from "../utils/tuningConfig";
import { IError, ILogEntry, Seconds, Subject, ValueSubject } from '@vkontakte/videoplayer-shared';
import { ChromecastState, IConfig, IExternalTextTrack, IPlayer, ISeekRequest, ITextTrack, PlaybackState, StartStatus, VideoFormat } from './types';
export default class Player implements IPlayer {
    private subscription;
    private domContainer;
    private providerContainer?;
    private chromecastInitializer;
    private logger;
    private explicitInitialQuality;
    private config;
    private tuning;
    private throughputEstimator;
    private isPlaybackStarted;
    private initedAt;
    private desiredState;
    info: {
        playbackState$: ValueSubject<PlaybackState>;
        position$: ValueSubject<number>;
        duration$: ValueSubject<number>;
        muted$: ValueSubject<boolean>;
        volume$: ValueSubject<number>;
        availableQualities$: ValueSubject<VideoQuality[]>;
        availableQualitiesFps$: ValueSubject<Partial<Record<VideoQuality, number>>>;
        currentQuality$: ValueSubject<VideoQuality | undefined>;
        isAutoQualityEnabled$: ValueSubject<boolean>;
        autoQualityLimitingAvailable$: ValueSubject<boolean>;
        autoQualityLimits$: ValueSubject<QualityLimits>;
        currentPlaybackRate$: ValueSubject<number>;
        currentBuffer$: ValueSubject<StartEnd<number>>;
        isBuffering$: ValueSubject<boolean>;
        isStalled$: ValueSubject<boolean>;
        isEnded$: ValueSubject<boolean>;
        isLooped$: ValueSubject<boolean>;
        isLive$: ValueSubject<boolean | undefined>;
        liveTime$: ValueSubject<number | undefined>;
        currentFormat$: ValueSubject<VideoFormat | undefined>;
        availableTextTracks$: ValueSubject<ITextTrack[]>;
        currentTextTrack$: ValueSubject<string | undefined>;
        throughputEstimation$: ValueSubject<number | undefined>;
        rttEstimation$: ValueSubject<number | undefined>;
        videoBitrate$: ValueSubject<number | undefined>;
        hostname$: ValueSubject<string | undefined>;
        httpConnectionType$: ValueSubject<HttpConnectionType | undefined>;
        httpConnectionReused$: ValueSubject<boolean | undefined>;
        chromecastState$: ValueSubject<ChromecastState>;
        chromecastDeviceName$: ValueSubject<string | undefined>;
        intrinsicVideoSize$: ValueSubject<{
            width: number;
            height: number;
        } | undefined>;
    };
    events: {
        inited$: Subject<void>;
        started$: Subject<boolean>;
        startAttempt$: Subject<StartStatus>;
        willPause$: Subject<void>;
        willResume$: Subject<void>;
        willDestruct$: Subject<void>;
        watchCoverageRecord$: Subject<StartEnd<number>>;
        watchCoverageLive$: Subject<StartEnd<number>>;
        managedError$: Subject<IError>;
        fatalError$: Subject<IError>;
        ended$: Subject<void>;
        looped$: Subject<number>;
        seeked$: Subject<void>;
        willSeek$: Subject<ISeekRequest>;
        firstBytes$: Subject<number>;
        firstFrame$: Subject<number>;
        canplay$: Subject<number>;
        log$: Subject<ILogEntry>;
    };
    experimental: {
        element$: ValueSubject<HTMLElement | undefined>;
        enableDebugTelemetry$: ValueSubject<boolean>;
        dumpTelemetry: (receiver: (value: Record<string, any>) => void) => void;
    };
    constructor(tuning?: IOptionalTuningConfig);
    initVideo(config: IConfig): IPlayer;
    destroy(): void;
    play(): IPlayer;
    pause(): IPlayer;
    stop(): IPlayer;
    seekTime(time: Seconds, forcePrecise?: boolean): IPlayer;
    /**
     * NOTE: Сейчас вызов `seekPercent` до получения `duration` не сработает.
     * @param percent: number [0, 1];
     */
    seekPercent(percent: number): IPlayer;
    setVolume(percent: number): IPlayer;
    setMuted(muted: boolean): IPlayer;
    setQuality(quality: VideoQuality): IPlayer;
    setAutoQuality(enable: boolean): IPlayer;
    setAutoQualityLimits(limits: QualityLimits): IPlayer;
    setPlaybackRate(playbackRate: PlaybackRate): IPlayer;
    setExternalTextTracks(tracks: Omit<IExternalTextTrack, 'type'>[]): IPlayer;
    selectTextTrack(id: ITextTrack['id'] | undefined): IPlayer;
    setTextTrackCueSettings(settings: ICueSettings): IPlayer;
    setLooped(isLooped: boolean): IPlayer;
    toggleChromecast(): void;
    getExactTime(): Seconds;
    getAllLogs(): ILogEntry[];
    private initDesiredStateSubscriptions;
    private initProviderContainerSubscription;
    private initChromecastSubscription;
    private initStartingVideoTrack;
    private setStartingVideoTrack;
    private initLogs;
    private initDebugTelemetry;
}
