import { IError, IObservable, Milliseconds, Seconds } from '@vkontakte/videoplayer-shared';
import { ApiEnv, ConnectionType, ContentType, Quality, ScreenDestination } from './types';
export interface IOneStat {
    /**
     * Лучше авторизоваться сразу, чтобы избежать ситуации:
     * 1. Накапливаем запросы в очереди через debounce send
     * 2. Пользователь закрывает приложение
     * 3. Запрос пытается уйти через sendBeacon и падает без авторизации
     */
    authorize(): Promise<unknown>;
    /**
     * Обновляет общие параметры событий
     */
    updateContext(context: Partial<IStatContext>): void;
    /**
     * Ставит отправку событий на паузу. Они будут накапливаться до вызова `resume()`
     */
    pause(): void;
    /**
     * Снимает паузу отправки событий
     */
    resume(): void;
    /**
     * Деструктор класса
     */
    destroy(): void;
    /**
     * Плеер создался и получил ссылку
     */
    logInited(): void;
    /**
     * Плеер готов начать воспроизведение
     */
    logReady(payload: IReadyPayload): void;
    /**
     * Первый старт видео. Отправляется 1 раз, когда фактически началось воспроизведение ролика, а также после зацикливания, но не после паузы.
     *
     * В документации API может называться `play`
     */
    logStarted(payload: IActionPlayPayload): void;
    /**
     *  Возобновление после паузы
     *
     *  В документации API может называться `play_toggle`
     */
    logPlay(): void;
    /**
     *  Постановка видео на паузу
     */
    logPause(payload: IPausePayload): void;
    /**
     * перемотка видео
     */
    logSeek(): void;
    /**
     * Промежутки видео, которые были просмотрены пользователем.
     * Время указывается в секундах от начала ролика (т.е. является позицией).
     */
    logWatchCoverageRecord(payload: IWatchCoveragePayload): void;
    /**
     * Промежутки видео, которые были просмотрены пользователем.
     * Время указывается в виде UTC timestamp'ов.
     */
    logWatchCoverageLive(payload: IWatchCoveragePayload): void;
    /**
     * Буфер пуст и пользователь видит залипший кадр.
     */
    logEmptyBuffer(payload: IEmptyBufferPayload): void;
    /**
     * Получен первый кусок данных контента от сервера раздачи видео
     */
    logFirstBytes(payload: IFirstBytesPayload): void;
    /**
     * Пользователь увидел первый кадр
     */
    logFirstFrame(payload: IFirstFramePayload): void;
    logDownloadSpeed(payload: IDownloadSpeedPayload): void;
    /**
     * произошла ошибка
     */
    logError(payload: IErrorPayload): void;
    logAdSlotRequest(): void;
    logAdStarted(sectionType: string): void;
    logAdPaused(): void;
    logAdResumed(): void;
    logAdEnded(): void;
    logAdSkipped(): void;
    logAdClicked(): void;
    experimental: {
        error$: IObservable<IError>;
    };
}
export interface IActionPlayPayload {
    /**
     * время в секундах от начала ролика
     */
    position: Seconds;
}
export interface IPausePayload {
    /**
     * время в секундах: сколько просмотрено от начала ролика
     */
    position: Seconds;
}
export interface IReadyPayload {
    /**
     * время в миллисекундах с события inited
     */
    time: Milliseconds;
}
export interface IFirstBytesPayload {
    /**
     * время в миллисекундах с события inited
     */
    time: Milliseconds;
}
export interface IFirstFramePayload {
    /**
     * время в миллисекундах с события inited
     */
    time: Milliseconds;
}
export interface IEmptyBufferPayload {
    /**
     * время в миллисекундах которое пользователь видел застывшую картинку
     */
    duration: Milliseconds;
}
export interface IDownloadSpeedPayload {
    /**
     * Скорость в килобайтах (!) в секунду
     */
    speed: number;
}
export interface IErrorPayload {
    /**
     * строка из символов(без пробелов): тип ошибки
     */
    errorType: string;
}
export interface IStatContext {
    /**
     * Ид видео
     */
    movieId: number;
    quality?: Quality;
    destination?: ScreenDestination;
    contentType?: ContentType;
    albumId?: string;
    vkPlaylistId?: string;
    vkAppId?: string;
    /**
     * Раздел сайта на котором играет видео: Лента, плеер, личные сообщения, ...
     */
    place?: string;
    cdnHostname?: string;
    connectionType?: ConnectionType;
    connectionReused?: boolean;
    autoplay?: boolean;
    trackCode?: string;
}
export interface IConfig {
    requestRetryCount: number;
}
export interface IConstructorParams {
    apiEnv: ApiEnv;
    config?: Partial<IConfig>;
    refreshAuthToken?: () => Promise<string>;
}
export interface IWatchCoveragePayload {
    start: number;
    end: number;
}
export declare class OneStat implements IOneStat {
    private api;
    private logger;
    private config;
    private subscription;
    experimental: {
        error$: IObservable<IError>;
    };
    private statContext;
    constructor(statContext: IStatContext, params: IConstructorParams);
    updateContext(newContext: Partial<IStatContext>): void;
    authorize(authToken?: string): Promise<unknown>;
    pause(): void;
    resume(): void;
    destroy(): void;
    logInited(): void;
    logReady(payload: IReadyPayload): void;
    logStarted(payload: IActionPlayPayload): void;
    logPlay(): void;
    logPause(payload: IPausePayload): void;
    logSeek(): void;
    logFirstBytes(payload: IFirstBytesPayload): void;
    logFirstFrame(payload: IFirstFramePayload): void;
    logError(payload: IErrorPayload): void;
    logWatchCoverageRecord(payload: IWatchCoveragePayload): void;
    logWatchCoverageLive(payload: IWatchCoveragePayload): void;
    logEmptyBuffer(payload: IEmptyBufferPayload): void;
    logDownloadSpeed(payload: IDownloadSpeedPayload): void;
    logAdSlotRequest(): void;
    logAdStarted(sectionType: string): void;
    logAdPaused(): void;
    logAdResumed(): void;
    logAdEnded(): void;
    logAdSkipped(): void;
    logAdClicked(): void;
    private log;
    private crateLogItem;
}
